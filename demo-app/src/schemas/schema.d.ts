/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/places": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns all places. */
        get: operations["getPlaces"];
        put?: never;
        /**
         * returns place information for a given place request
         * @description Returns places for a given place request based on the OJP specification.
         *
         */
        post: operations["postPlaces"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/places/{placeId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** returns a place */
        get: operations["getPlacesId"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trips-collection": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * returns a collection of trips for a given OJP trip request
         * @description Returns trips for a given trip request based on the OJP specification.
         *
         */
        post: operations["postTrips"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trips-collections/{tripsCollectionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns a collection of trips.
         * @description Returns a collection of trips for a for a given trips collection id.
         *     The unique codes of the origin and destination can be resolved using the places service.
         *
         */
        get: operations["getTripsCollectionId"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trips/{tripId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns a trip element representing a travel trip.
         * @description A trip consists of one or more legs for a given tripId. Depending on the
         *     embed either references or full location definitions is returned.
         *
         */
        get: operations["getTripsId"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/offers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Returns offers for trips or trip search criteria. */
        post: operations["createOffers"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/booked-offers/{bookedOfferId}/additional-offers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get additional offers of booked offer for a given booking. A provider can decide to allow or reject additional offers admissions, reservations or ancillaries on an confirmed booking. */
        get: operations["getBookingBookedOffersAdditionalOffers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/on-hold-offer": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Creates an on hold offer.
         * @description On hold offer created
         *
         */
        post: operations["createOnHoldOffer"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/on-hold-offer/{onHoldOfferId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Deletes the on hold offer */
        delete: operations["deleteOnHoldOffer"];
        options?: never;
        head?: never;
        /** Confirms the on hold offer. */
        patch: operations["confirmOnHoldOffer"];
        trace?: never;
    };
    "/bookings/{bookingId}/passengers/{passengerId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns the passenger's information at booking step. */
        get: operations["getBookingPassengersId"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** Allows updating a passenger's information at booking step. */
        patch: operations["patchBookingPassenger"];
        trace?: never;
    };
    "/bookings/{bookingId}/purchaser": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns the purchaser's information at booking step. */
        get: operations["getBookingPurchaser"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** Allows updating a purchaser's information at booking step. */
        patch: operations["patchBookingPurchaser"];
        trace?: never;
    };
    "/bookings/{bookingId}/booked-offers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Creates bookedOffers from offers and adds them in a booking. */
        post: operations["postBookingBookedOffers"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/booked-offers/{bookedOfferId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets a bookedOffer of a booking. */
        get: operations["getBookingBookedOffersId"];
        put?: never;
        post?: never;
        /** Delete a bookedOffer from a booking. */
        delete: operations["deleteBookingBookedOffersId"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/booked-offers/{offerId}/passengers/{passengerId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete a passenger from bookedOffer of a booking.
         * @description Deletes all booked offer parts of the passenger only if this valid from a tariff point of view. This implies that the offer part are sufficiently partitioned and no repricing is needed.
         *
         */
        delete: operations["deleteBookingBookedOffersIdPassengerId"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/booked-offers/{bookedOfferId}/reservations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Adds a reservation to a booking. A provider can decide to allow or reject additional admissions, reservations or ancillaries on an confirmed booking. */
        post: operations["createBookingBookedOffersReservations"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/booked-offers/{bookedOfferId}/reservations/{reservationId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Removes a reservation from a booking in case the reservation was not yet confirmed. On confirmed reservations use the refund. */
        delete: operations["deleteBookingBookedOffersReservations"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/booked-offers/{bookedOfferId}/ancillaries": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Adds an ancillary to a booking. A provider can decide to allow or reject additional admissions, reservations or ancillaries on an confirmed booking. */
        post: operations["createBookingBookedOffersAncillaries"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/booked-offers/{bookedOfferId}/ancillaries/{ancillaryId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Removes an ancillary from a booking in case the ancillary is not jet confirmed. On confirmed ancillaries use the refund. */
        delete: operations["deleteBookingBookedOffersAncillary"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/booked-offers/{bookedOfferId}/admissions/{admissionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Removes an admission from a booking. In case the admission is not confirmed. On a confirmed admission use the refund.
         * @description Removes an admission from pre-booked booking.It is up to the provider
         *     to change or remove dependent bookedOfferParts or to reject the request.
         *     A repricing might occur.
         *
         */
        delete: operations["deleteBookingBookedOffersAdmission"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Creates a booking based on a previously requested offer. */
        post: operations["postBookings"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a booking. */
        get: operations["getBookingsId"];
        put?: never;
        post?: never;
        /**
         * Deletes a booking.
         * @description It is only possible before the booking is confirmed or in case of a technical problem in confirming multiple
         *     independent bookings within a sales transaction. Deletes on a confirmed booking must be documented
         *     and evidence on the issue must be provided on request.
         *     The delete on a confirmed booking is allowed immediately after the confirmation of the booking,
         *     but must be repeated according to the error handling rules in case the delete fails.
         *
         */
        delete: operations["deleteBookingsId"];
        options?: never;
        head?: never;
        /**
         * Updates a booking but does *not* confirm the booking.
         * @description Updates fulfillment types, place selection and add payment. Does *not* confirm the booking. The booking is confirmed by calling 'POST /bookings/{bookingId}/fulfillments'.
         *
         */
        patch: operations["updateBooking"];
        trace?: never;
    };
    "/bookings/{bookingId}/cleanup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Performs a complete cleanup of a booking in a single step
         * @description The booking is cleaned up completely: confirmed items are refunded, and unconfirmed items are deleted.
         *
         */
        post: operations["postBookingCleanup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns the history of changes to a booking. */
        get: operations["getBookingsIdHistory"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings-search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Search for bookings based on search parameters. */
        post: operations["searchBookings"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/split": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Split a booking into multiple bookings.
         * @description Splits a booking into a set of bookings according to the defined groups of a passenger(s). Only possible if allowed by the underlying tariff, if the bookedOffers are sufficiently partitioned and no pricing is needed.
         *
         */
        post: operations["splitBookings"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/fulfillments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Confirms the booking a triggers the fulfillment of the booking synchronously or asynchronously.
         * @description Confirms the booking and triggers the fulfillment of the booking.
         *
         *     If the fulfillments are created synchronously the service directly returns the fulfillments. The fulfillments are then in state FULFILLED.
         *
         *     If the fulfillments are created asynchronously the service starts the creation of the fulfillments. The fulfillmentIds may or may not returned. The fulfillments are in stage CONFIRMED. The booking needs to be retrieved later to obtain the fulfillments.
         *
         */
        post: operations["postFulfillments"];
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Optionally finalizes the fulfillments in asynchronous mode.
         * @description Optionally finalizes the fulfillment in case of an asynchronous fulfillment mode when the provider doesn't complete the asynchronous fulfillment automatically.
         *
         *     This step may be used as an indication of the `proof of delivery` to disallow the cancellation of booking.
         *
         */
        patch: operations["finalizeFulfillments"];
        trace?: never;
    };
    "/fulfillments/{fulfillmentId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns the fulfillment, aka. ticket for the provided id. */
        get: operations["getFulfillmentId"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Activates a fulfillment, i.e. changes the status to AVAILABLE.
         * @description Changes the fulfillment to status AVAILABLE. In the case of multi-journey product, one of the fulfillment is now 'activated' and can be used to travel.
         *
         */
        patch: operations["patchFulfillmentId"];
        trace?: never;
    };
    "/bookings/{bookingId}/refund-offers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Initiates a refund process by creating a refundOffer resource.
         * @description The RefundOffer contains the required information on the potential operation. One refund offer can then be
         *     accepted via a PATCH, deleted or left to die at the end of its lifetime.
         *
         */
        post: operations["postRefundOffers"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/refund-offers/{refundOfferId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns the refund offer for the ids provided. */
        get: operations["getRefundOffers"];
        put?: never;
        post?: never;
        /** Deletes a refundOffer without waiting for expiry. */
        delete: operations["deleteRefundOffers"];
        options?: never;
        head?: never;
        /** Allows to accept and confirm a refund offer. */
        patch: operations["patchRefundOffers"];
        trace?: never;
    };
    "/bookings/{bookingId}/release-offers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Initiates a release process by creating a releaseOffers resource. */
        post: operations["postReleaseOffers"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/release-offers/{releaseOfferId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns the release offer for the ids provided. */
        get: operations["getReleaseOffer"];
        put?: never;
        post?: never;
        /** Deletes a release offer without waiting for expiry. */
        delete: operations["deleteReleaseOffers"];
        options?: never;
        head?: never;
        /** Allows to accept and confirm a release offer. */
        patch: operations["patchReleaseOffers"];
        trace?: never;
    };
    "/bookings/{bookingId}/cancel-fulfillments-offers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Initiates a cancel fulfillments process
         * @description Initiates a cancel fulfillments process by creating a
         *     cancelFulfillmentsOffers resource.
         *
         */
        post: operations["postCancelFulfillmentsOffers"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/cancel-fulfillments-offers/{cancelFulfillmentsOfferId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns the cancel fulfillments offer for the ids provided. */
        get: operations["getCancelFulfillmentOffers"];
        put?: never;
        post?: never;
        /** Deletes a cancel fulfillments offer without waiting for expiry. */
        delete: operations["deleteCancelFulfillmentOffers"];
        options?: never;
        head?: never;
        /** Allows to accept and confirm a cancel fulfillments offer. */
        patch: operations["patchCancelFulfillmentsOffers"];
        trace?: never;
    };
    "/bookings/{bookingId}/exchange-offers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Returns exchange offers for specified fulfillments
         * @description Returns exchange offers for specified fulfillments submitted given
         *     requested new trip characteristics.
         *
         */
        post: operations["createExchangeOffersCollection"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/exchange-operations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Pre-books an exchangeOffer as part of an exchange operation. */
        post: operations["createBookingsExchangeOperations"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/exchange-operations/{exchangeOperationId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns the exchange operation with the id provided.
         * @description Returns the exchange operation with the id provided. It may be a
         *     provisional or a confirmed exchange.
         *
         */
        get: operations["getBookingsExchangeOperations"];
        put?: never;
        post?: never;
        /** Cancels an ongoing exchange operation in provisional state. */
        delete: operations["deleteBookingsExchangeOperation"];
        options?: never;
        head?: never;
        /** Allows to update an ongoing exchange operation. */
        patch: operations["updateBookingsExchangeOperations"];
        trace?: never;
    };
    "/complaints": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Allows adding a complaint.
         * @description Create a complaint request for part of a booking.
         *
         */
        post: operations["createComplaint"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/complaints/{complaintId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns a complaint.
         * @description Get a complaint including its current state.
         *
         */
        get: operations["getComplaint"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Allows updating a complaint.
         * @description Update a complaint request, i.e add missing documents or change state.
         *
         */
        patch: operations["patchComplaint"];
        trace?: never;
    };
    "/coach-layouts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns all coach layouts.
         * @description Retrieve the coach layout description needed for graphical reservation. The coach
         *     layouts can either be retrieved as a complete list or specificity for a train identified via offerId and reservationId or fareId
         *
         */
        get: operations["getCoachLayouts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/coach-layouts/{layoutId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns a coach layout for a provided id.
         * @description Retrieve a coach layout description needed for graphical reservation for a given layout id.
         *
         */
        get: operations["getCoachLayoutsLayoutId"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/reduction-cards": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns all reduction card definitions.
         * @description returns a collection of reduction card definitions
         *
         */
        get: operations["getReductionCards"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/zones": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns all zone definitions. */
        get: operations["getZones"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/documents": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Allows adding a document to a booking. */
        post: operations["createDocuments"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/documents/{documentId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns a booking document.
         * @description booking documents found
         *
         */
        get: operations["getDocument"];
        put?: never;
        post?: never;
        /** Delete a document from a booking. */
        delete: operations["deleteBookingsDocumentsId"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/reimbursements": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create reimbursement for a booking.
         * @description Create a reimbursement request for part of a booking.
         *
         */
        post: operations["createReimbursement"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{bookingId}/reimbursements/{reimbursementId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get reimbursement of a booking.
         * @description Get reimbursement including its current state.
         *
         */
        get: operations["getReimbursement"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update reimbursement of a booking.
         * @description Update a reimbursement request, i.e add missing documents or change state.
         *
         */
        patch: operations["updateReimbursement"];
        trace?: never;
    };
    "/travel-accounts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a travel account. */
        get: operations["getTravelAccounts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/availabilities/place-map": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get place map including availabilities.
         * @description Get place map including availabilities.
         *
         */
        get: operations["getAvailabilitiesPlaceMap"];
        put?: never;
        /**
         * Get multiple place maps including availabilities.
         * @description Get multiple place maps including availabilities.
         *
         */
        post: operations["getAvailabilitiesPlaceMaps"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/availabilities/nearby": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get availabilities nearby a given place.
         * @description Get availabilities nearby a given place.
         *
         */
        get: operations["getAvailabilitiesNearby"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/availabilities/preferences": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get availabilities for a set of preferences.
         * @description Get availabilities for a set of preferences.
         *
         */
        get: operations["getAvailabilitiesPreferences"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/products": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns all products. */
        get: operations["getProducts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/products/{productId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a product for the provided id. */
        get: operations["getProductsId"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        AbstractBookingPart: {
            /** @description Attribute is used as discriminator for inheritance between data types. */
            objectType: string;
            id: string;
            summary?: string | null;
            /**
             * Format: date-time
             * @description Validity of offer towards passenger
             *
             */
            createdOn: string;
            /**
             * Format: date-time
             * @deprecated
             * @description confirmationTimeLimit in booking should be used.
             *     Date until the booking part needs to be confirmed. Must be provided for a booking part in PREBOOKED stated.
             *     For later states, the value is ignored and can be null.
             *
             */
            confirmableUntil?: string;
            /** Format: date-time */
            validFrom: string;
            /**
             * Format: date-time
             * @description Validity of offer towards passenger
             *
             */
            validUntil?: string | null;
            /** Format: date-time */
            confirmedOn?: string | null;
            price: components["schemas"]["Price"];
            /** @description Amount refunded or to be refunded to the purchaser depending on the product conditions and status of the booking Part */
            refundAmount?: components["schemas"]["Price"];
            tripCoverage?: components["schemas"]["TripCoverage"];
            /** @description Id of the product representing the commercial attributes of this booking part. Although not currently
             *     mandatory, this attribute should in all cases be filled in order to allow matching a booking response
             *     to the data in the booking request
             *      */
            summaryProductId?: string;
            /** @description In offer mode, in almost all cases exactly one product is referenced. Only on some French
             *     trips consisting of a TGV and a TER two products need to be used.
             *     In fare mode, no product exists as first needs to created from the different fares.
             *      */
            products?: components["schemas"]["ProductLegAssociation"][];
            status: components["schemas"]["BookingPartStatus"];
            offerMode?: components["schemas"]["OfferMode"];
            /** @description The unique booking code for the part in the provider system.
             *      */
            bookingPartCode?: string;
            /**
             * @deprecated
             * @description reference to the booking in the downstream distributor system
             *
             */
            distributorBookingRef?: string | null;
            /**
             * @deprecated
             * @description reference to the booking in the downstream distributor system
             *
             */
            retailerBookingRef?: string | null;
            /** @description Id of the passenger
             *      */
            passengerIds: string[];
            availableFulfillmentOptions?: components["schemas"]["FulfillmentOption"][];
            refundable: components["schemas"]["RefundType"];
            exchangeable: components["schemas"]["ExchangeableType"];
            /** @description Fine grained specification of the after sale condition of the booking.
             *      */
            afterSaleConditions?: components["schemas"]["AfterSaleCondition"][];
            afterSalesOverrideDetails?: components["schemas"]["AfterSalesOverrideDetails"];
            appliedCorporateCodes?: components["schemas"]["CorporateCode"][];
            appliedPassengerTypes?: components["schemas"]["AppliedPassengerType"][];
            appliedPromotionCodes?: components["schemas"]["PromotionCode"][];
            appliedReductions?: components["schemas"]["CardReference"][];
            indicatedConsumption?: components["schemas"]["IndicatedConsumption"];
            accountingRef?: components["schemas"]["AccountingRef"];
            grantedReductionAmounts?: components["schemas"]["GrantedReductionAmounts"];
        };
        /** @description reference to accounting data in case the accounting is not provided by the API provider
         *      */
        AccountingRef: {
            accountingCompany: components["schemas"]["CompanyRef"];
            /** @description ids of accounting data used to link the booking part with accounting data in the billing send by the accounting company
             *      */
            accountingIds?: string[];
        };
        /** @description Generic offer object that contains all common information about an offer.
         *      */
        AbstractOfferPart: {
            /** @description Attribute is used as discriminator for inheritance between data types. */
            objectType: string;
            id: string;
            /** @description A human-readable description of the Offer.
             *      */
            summary?: string | null;
            /** Format: date-time */
            createdOn: string;
            /**
             * Format: date-time
             * @description Time from which on the offer can be used, e.g. travel.
             *
             */
            validFrom: string;
            /**
             * Format: date-time
             * @description Time until the offer can be used, e.g. travel.
             *
             */
            validUntil?: string | null;
            price: components["schemas"]["Price"];
            tripCoverage?: components["schemas"]["TripCoverage"];
            /**
             * Format: date-time
             * @description Indicates until when the price for the given offer is guaranteed.
             *
             */
            priceGuaranteedUntil?: string | null;
            offerMode: components["schemas"]["OfferMode"];
            /**
             * @description Indicates whether the offerId can be used in more than one booking.
             *
             * @default false
             */
            isReusable: boolean | null;
            passengerRefs: string[];
            /** Format: int32 */
            numericAvailability?: number | null;
            refundable: components["schemas"]["RefundType"];
            exchangeable: components["schemas"]["ExchangeableType"];
            afterSalesConditions?: components["schemas"]["AfterSaleCondition"][];
            /** @description List of tags (and their type) that allow identifying sets of compatible offers when trying to combine multiple offers covering one single trip.
             *     At least one (not all) tripTags must be in common to allow combination
             *     If no tag is provided, there is no trip constraint on this specific offer.
             *      */
            tripTags?: string[] | null;
            /** @description List of tags (and their type) that allow identifying sets of compatible offers when booking a return trip
             *     involving return-specific fares. All returnTags must be present in the counterpart offer to allow combination
             *     If no tag is provided, there is no return constraint on this specific offer.
             *      */
            returnTags?: string[] | null;
            offerTag?: components["schemas"]["OfferTag"];
            requestedInformation?: components["schemas"]["RequestedInformation"];
            /** @description Id of the product representing the commercial attributes of this offer part. Although not currently mandatory, this attribute should in all cases be facilitate product based processing at the client */
            summaryProductId?: string;
            products: components["schemas"]["ProductLegAssociation"][];
            availableFulfillmentOptions: components["schemas"]["FulfillmentOption"][];
            appliedCorporateCodes?: components["schemas"]["CorporateCode"][];
            appliedPassengerTypes?: components["schemas"]["AppliedPassengerType"][];
            appliedPromotionCodes?: components["schemas"]["PromotionCode"][];
            /** @deprecated */
            appliedReductionCardTypes?: components["schemas"]["ReductionCardType"][];
            regionalValiditySummary?: components["schemas"]["RegionalValiditySummary"];
            indicatedConsumption?: components["schemas"]["IndicatedConsumption"];
            grantedReductionAmounts?: components["schemas"]["GrantedReductionAmounts"];
            /** @description Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        AbstractTravelAccount: {
            /** @description Attribute is used as discriminator for inheritance between data types. */
            objectType: string;
            holder?: components["schemas"]["PersonDetail"];
            issuer: components["schemas"]["CompanyRef"];
            /** Format: date-time */
            validFrom: string;
            /** Format: date-time */
            validUntil: string;
            number: string;
        };
        AbstractTravelAccountUnit: {
            /** @description Attribute is used as discriminator for inheritance between data types. */
            objectType: string;
        };
        /**
         * @description Accommodation sub type definition out of the
         *     [Accommodation Sub Type Code List](https://osdm.io/spec/catalog-of-code-lists/#PlaceProperty)
         *     Listed values here are examples.
         *
         * @default ANY_SEAT
         */
        AccommodationSubType: string;
        /**
         * @description Accommodation type definition out of the
         *     [Accommodation Type Code List](https://osdm.io/spec/catalog-of-code-lists/#AccomodationType)
         *     Listed values here are examples.
         *
         * @default SEAT
         */
        AccommodationType: string;
        /**
         * @description Actual Passenger type according to UIC passenger, i.e. passenger type list.
         *     Returns the passenger type according to the underlying fare system.
         *     E.g. a passenger of type PERSON is categorized as a ADULT or YOUTH.
         *     Values from the [Passenger Type Code List](https://osdm.io/spec/catalog-of-code-lists/#PassengerType)
         *     Listed values here are examples.
         *
         * @default PERSON
         */
        ActualPassengerType: string;
        AdditionalOfferCollectionResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            offers?: components["schemas"]["Offer"][];
        };
        /** @description A descriptive data associated with a place that can be used to describe the unique geographical context of a
         *     place for the purposes of identifying it. may be refined as either a road address, a postal address or both.
         *     Provided by OJP.
         *      */
        Address: {
            objectType: "Address";
        } & (Omit<components["schemas"]["Place"], "objectType"> & {
            /**
             * @description Name or description of address for use in passenger information.
             *
             * @example Oude Trambaan 7, 2265CA Leidschendam, Nederland
             */
            name?: string | null;
            /**
             * @description id of the address
             *
             * @example NL:1916200000022621
             */
            code?: string | null;
            /**
             * @description Country of the address.
             *
             * @example The Netherlands
             */
            countryName?: string | null;
            countryCode?: components["schemas"]["CountryCode"];
            /**
             * @description Postal code of the address.
             *
             * @example 2265CA
             */
            postCode?: string | null;
            /**
             * @description City name
             *
             * @example Leidschendam
             */
            city?: string | null;
            /**
             * @description TopographicPlace name of the address. If set it should at least contain the city name.
             *
             * @example Leidschendam
             */
            topographicPlaceName?: string | null;
            /**
             * @description Street name of the address. Can also contain the house number.
             *
             * @example Oude Trambaan
             */
            street?: string | null;
            /**
             * @description House number of the address. House number can either be in this separate field, or can be
             *     contained in the street field.
             *
             * @example 7
             */
            houseNumber?: string | null;
            ref?: components["schemas"]["AddressRef"];
        });
        /** @description Reference to an Address.
         *      */
        AddressRef: {
            objectType: "AddressRef";
        } & (Omit<components["schemas"]["PlaceRef"], "objectType"> & {
            addressRef: string;
        });
        PostalAddress: {
            /**
             * @description Country of the address.
             *
             * @example The Netherlands
             */
            countryName?: string | null;
            countryCode?: components["schemas"]["CountryCode"];
            /**
             * @description Postal code of the address.
             *
             * @example 2265CA
             */
            postCode?: string | null;
            /**
             * @description City name
             *
             * @example Leidschendam
             */
            city?: string | null;
            /**
             * @description Street name of the address. Can also contain the house number.
             *
             * @example Oude Trambaan
             */
            street?: string | null;
            /**
             * @description House number of the address. House number can either be in this separate field, or can be
             *     contained in the street field.
             *
             * @example 7
             */
            houseNumber?: string | null;
        };
        /** @description An admission represents a travel right, or the entitlement to travel onboard a train between
         *     the given origin and destination, following the given route. It does not include a seat reservation.
         *      */
        Admission: {
            objectType: "Admission";
        } & (Omit<components["schemas"]["AbstractBookingPart"], "objectType"> & {
            /** @default false */
            isReservationRequired: boolean | null;
            feeRefs?: components["schemas"]["BookingPartReference"][];
            reservationRefs?: components["schemas"]["BookingPartReference"][];
            ancillaryRefs?: components["schemas"]["BookingPartReference"][];
            regulatoryConditions?: components["schemas"]["RegulatoryCondition"][];
        });
        /** @description An admission represents a travel right, or the entitlement to travel onboard a train between
         *     the given origin and destination, following the given route. It does not include a seat reservation.
         *      */
        AdmissionOfferPart: {
            objectType: "AdmissionOfferPart";
        } & (Omit<components["schemas"]["AbstractOfferPart"], "objectType"> & {
            isReservationRequired?: boolean | null;
            reservations?: components["schemas"]["ReservationRelation"][];
            ancillaries?: components["schemas"]["AncillaryRelation"][];
            feeRefs?: components["schemas"]["OfferPartReference"][];
            regulatoryConditions?: components["schemas"]["RegulatoryCondition"][];
            includedReservations?: components["schemas"]["ReservationOfferPart"][];
            throughTicketTags?: components["schemas"]["ThroughTicketTag"][];
        });
        /** @description After sale amounts for a given offer.
         *      */
        AfterSaleCondition: {
            condition?: components["schemas"]["AfterSaleConditionType"];
            /** Format: date-time */
            validFrom?: string | null;
            /** Format: date-time */
            validUntil?: string | null;
            afterSaleFee?: components["schemas"]["Price"];
            reimbursementMethod?: components["schemas"]["ReimbursementMethod"];
        };
        AfterSaleConditionType: string;
        AfterSalesConditionsLink: {
            /** @description Structured description of the after-sales conditions.
             *      */
            conditions: components["schemas"]["AfterSaleCondition"][];
            /**
             * @description Indicates that the after sales of this fare can be treated independently per person.
             *
             * @default false
             */
            isSupportingIndividualContracts: boolean | null;
        };
        /** @description If initial after sales conditions have been overwritten this object provides details on the original
         *     conditions and an explanation text for the customer
         *      */
        AfterSalesOverrideDetails: {
            initialAftersalesConditions?: components["schemas"]["AfterSaleCondition"][];
            /** @description Description for the change of conditions for the customer. */
            overrideDescription?: string;
            /** Format: date-time */
            validFrom?: string | null;
            /** Format: date-time */
            validUntil?: string | null;
            initialExchangeableType?: components["schemas"]["ExchangeableType"];
            initialRefundType?: components["schemas"]["RefundType"];
        };
        /** @description Describes the situation at a stop or station at which the passenger alights from a Leg
         *     of a trip including time-related information. Provided by OJP.
         *      */
        Alight: {
            stopPlaceRef: components["schemas"]["StopPlaceRef"];
            /** @example Luzern */
            stopPlaceName: string;
            /**
             * @description Name of the bay/quay/terminal where to board/alight from the vehicle. According to
             *     planned timetable.
             *
             * @example 3
             */
            plannedStopPointName?: string | null;
            /**
             * @description Name of the bay/quay/terminal where to board the vehicle. As to the latest realtime status.
             *
             * @example 8
             */
            estimatedStopPointName?: string | null;
            serviceArrival: components["schemas"]["ServiceTime"];
            status?: components["schemas"]["StopCallStatus"];
        };
        /** @description Minimal alight specification
         *      */
        AlightSpecification: {
            stopPlaceRef: components["schemas"]["StopPlaceRef"];
            serviceArrival: components["schemas"]["ServiceTime"];
        };
        Ancillary: {
            objectType: "Ancillary";
        } & (Omit<components["schemas"]["AbstractBookingPart"], "objectType"> & {
            feeRefs?: components["schemas"]["BookingPartReference"][];
            type: components["schemas"]["AncillaryType"];
        });
        AncillaryGroup: {
            id: string;
            name: string;
            ancillaryRefs: components["schemas"]["OfferPartReference"][];
        };
        AncillaryOfferPart: {
            objectType: "AncillaryOfferPart";
        } & (Omit<components["schemas"]["AbstractOfferPart"], "objectType"> & {
            feeRefs?: components["schemas"]["OfferPartReference"][];
            /** @description Categorization of the ancillary such as 'Meal' or 'Gift'.
             *      */
            category?: string | null;
            type: components["schemas"]["AncillaryType"];
        });
        AncillaryRelation: {
            /** Format: int32 */
            minGroupItemsToBeBooked: number;
            /** Format: int32 */
            maxGroupItemsToBeBooked?: number | null;
            ancillaryGroup: components["schemas"]["AncillaryGroup"];
        };
        /** @description Is some cases one out of a set of ancillary offerparts must be booked.
         *      */
        AncillarySelection: {
            ancillaryId: string;
            passengerRefs: string[];
        };
        /** @description Values from the [Ancillary Category Code List](https://osdm.io/spec/catalog-of-code-lists/#AncillaryCategory)
         *     Listed values here are examples.
         *      */
        AncillaryType: string;
        /** @description Minimal specification of a passenger to request offers without any GDPR relevant attributes such as name or address.
         *
         *     Either the date of birth or the age at the time of travel needs to be set. We recommend to use date of birth as it is more stable than age.
         *      */
        AnonymousPassengerSpecification: {
            /** @description A stable reference to a passenger from other elements, or from caller system. When received in input of a request, it must be echoed back in the response.
             *      */
            externalRef: string;
            /**
             * Format: date
             * @description Date of birth of the passenger. Only needed for passengers of type persons, family child, PRM
             *     and wheelchair.
             *
             */
            dateOfBirth?: string | null;
            /** Format: int32 */
            age?: number | null;
            type: components["schemas"]["PassengerType"];
            prmNeeds?: components["schemas"]["PRMNeedType"][];
            cards?: components["schemas"]["CardReference"][];
            gender?: components["schemas"]["Gender"];
        };
        ApplicabilityType: string;
        TransactionContextType: string;
        /** @description Applied passenger types and reductions per passenger, per offer part and per part of the trip.
         *      */
        AppliedPassengerType: {
            /** @description id of the passenger.
             *     In the offer flow the id refers to the externalRef as the passenger id is created at booking time only.
             *      */
            passengerRef: string;
            type: components["schemas"]["ActualPassengerType"];
            /** @description Clear text representation of the actual passenger type, suitable to be presented to a client.
             *      */
            description: string;
            tripCoverage?: components["schemas"]["TripCoverage"];
            /** @deprecated */
            appliedReductionCardTypes?: components["schemas"]["ReductionCardType"][];
            appliedReductions?: components["schemas"]["CardReference"][];
        };
        /** @description Indication of items attached to the car
         *      */
        AttachableItemType: string;
        /** @description fare or offerParts which should be covered by the available seats */
        AvailabilityScope: {
            /**
             * @description if true the place map must include places for a single reservation or fare only
             * @default true
             */
            singleSelectionMapsRequired: boolean;
            partReferences: components["schemas"]["PartReference"][];
        };
        /** @description reference to a fare or offerPart */
        PartReference: {
            contextId: string;
            contextType: components["schemas"]["ContextType"];
            resourceId: string;
            resourceType: components["schemas"]["ResourceType"];
        };
        /**
         * @description status of the place or coach
         *
         * @default FREE
         * @enum {string}
         */
        AvailabilityStatus: "ALLOCATED" | "FREE" | "RESTRICTED";
        /** @description Describes the details of the available places.
         *      */
        AvailablePlace: {
            accommodationType: components["schemas"]["AccommodationType"];
            accommodationSubType: components["schemas"]["AccommodationSubType"];
            /** @description Selectable place properties for the offer. For AccommodationSubType=ANY_SEAT all available and bookable properties need to be returned to give a sales tool a list of possible selections.
             *      */
            placeProperties?: string[] | null;
            /**
             * Format: int32
             * @description For the AccommodationSubType=ANY_SEAT the total amount of places for the combination of AccommodationType and AccommodationSubType needs to returned.
             *
             */
            numericAvailability?: number | null;
            tripLegCoverage: components["schemas"]["TripLegCoverage"];
        };
        AvailablePlacePreferences: {
            /** @description possible preferences to be requested in reservation without changing the fare
             *      */
            preferenceGroups?: components["schemas"]["PlacePreferenceGroup"][];
            /** @description graphical reservation is supported, interface type 'NO','UIC_918',..
             *      */
            graphicalReservation?: string | null;
        };
        /**
         * @description Status of the request sent to the back office.
         *     Valid Values:
         *     - 'INITIATED'
         *     - 'EVALUATING'
         *     - 'DECIDED'
         *     - 'SETTLED'
         *     - 'INFORMATION_MISSING'
         *     - 'REQUEST_UPDATED': Additional information, i.e. documents have been provided which should trigger reevaluation.
         *
         * @enum {string}
         */
        BackOfficeStatus: "INITIATED" | "EVALUATING" | "DECIDED" | "SETTLED" | "INFORMATION_MISSING" | "REQUEST_UPDATED";
        /** @description bank account
         *      */
        BankAccountReference: {
            /** @description IBAN to be used in Europe
             *      */
            iban?: string | null;
            /** @description bank account id to be used outside of EU
             *      */
            accountId?: string | null;
            bankIdCode?: components["schemas"]["BankIdCode"];
            bankId?: string | null;
            /** @example John Doe */
            ownerName?: string | null;
        };
        BankIdCode: string;
        /** @description Item according to IRS 90918-9: FCB, TLB, SSB
         *     Values from the [Barcode Type Code List](https://osdm.io/spec/catalog-of-code-lists/#BarcodeType)
         *     Listed values here are examples.
         *      */
        BarCodeType: string;
        /** @description Policies that control the trip search behavior for both public and individual transport.
         *     Provided by OJP.
         *      */
        BaseTripPolicyFilter: {
            /**
             * @description The user is not able to climb one step, i.e. wheel chair.
             *
             * @default false
             */
            noSingleStep: boolean | null;
            /**
             * @description The user is not able to see.
             *
             * @default false
             */
            noSight: boolean | null;
        };
        /** @description Describes the the situation at a stop or station at which the passenger boards a Leg
         *     of a trip including time-related information. Provided by OJP.
         *      */
        Board: {
            stopPlaceRef: components["schemas"]["StopPlaceRef"];
            /** @example Luzern */
            stopPlaceName: string;
            /**
             * @description Name of the bay/quay/terminal where to board/alight from the vehicle. According to
             *     planned timetable.
             *
             * @example 3
             */
            plannedStopPointName?: string | null;
            /**
             * @description Name of the bay/quay/terminal where to board the vehicle. As to the latest realtime status.
             *
             * @example 8
             */
            estimatedStopPointName?: string | null;
            serviceDeparture: components["schemas"]["ServiceTime"];
            status?: components["schemas"]["StopCallStatus"];
        };
        /** @description Minimal board specification.
         *      */
        BoardSpecification: {
            stopPlaceRef: components["schemas"]["StopPlaceRef"];
            serviceDeparture: components["schemas"]["ServiceTime"];
        };
        /** @description The attribute 'offerSummary' is meaningful at trip-offer-collection response time only.
         *      */
        BookedOffer: {
            /** @description Note that the offerId returned does not necessarily match the offerId given in the Booking Request. */
            offerId: string;
            /** @description A stable reference to the id of the booked offer in the caller's system. When received in input of a request, it must be persisted and echoed back in the response.
             *      */
            externalRef?: string;
            /** @description A human-readable description of the booked offer.
             *      */
            summary?: string | null;
            admissions?: components["schemas"]["Admission"][];
            reservations?: components["schemas"]["Reservation"][];
            ancillaries?: components["schemas"]["Ancillary"][];
            fees?: components["schemas"]["Fee"][];
            fares?: components["schemas"]["Fare"][];
            tripCoverage?: components["schemas"]["TripCoverage"];
            appliedThroughTicketTags?: components["schemas"]["ThroughTicketTag"][];
            products?: components["schemas"]["Product"][];
        };
        BookedOfferAncillaryRequest: {
            offerId: string;
            ancillaryOfferId: string;
            passengerRefs: string[];
            tripCoverage?: components["schemas"]["TripCoverage"];
        };
        BookedOfferAncillaryResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            bookedOffers?: components["schemas"]["BookedOffer"][];
        };
        /** @description adding an offer to a booking as pre-booked. additional passengers that were not already in the booking are added in additional passengers existing passengers are referenced in passengerRef. */
        BookedOfferRequest: {
            offers: components["schemas"]["OfferSelection"][];
            /**
             * @deprecated
             * @description Existing passengers are linked with the given booking and do not need to be referenced in the request.
             *
             */
            passengers?: components["schemas"]["Passenger"][];
            additionalPassengerSpecifications?: components["schemas"]["PassengerSpecification"][];
            promotionCodes?: components["schemas"]["PromotionCode"][];
        };
        BookedOfferReservationRequest: {
            offerId: string;
            reservationOfferId: string;
            passengerRefs: string[];
            placeSelections: components["schemas"]["PlaceSelection"][];
            tripCoverage?: components["schemas"]["TripCoverage"];
        };
        BookedOfferReservationResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            bookedOffers?: components["schemas"]["BookedOffer"][];
        };
        BookedOfferResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            /** @deprecated */
            bookedOffer?: components["schemas"]["BookedOffer"];
            /** @description IDs of offers booked by the request. Will be always provided, single of the booked offer may not be provided in bookedOffer attribute.
             *      */
            bookedOfferIds?: string[];
        };
        BookedOfferSummary: {
            offerId: string;
            summary: string;
            bookingPartSummaries: components["schemas"]["BookingPartSummary"][];
        };
        Booking: {
            id: string;
            /** @description The unique booking code in the provider system. Usually refers to an order number or PNR. */
            bookingCode?: string;
            /** @description The unique booking reference in the provider system. Usually refers to an order number or PNR.
             *      */
            externalRef?: string | null;
            /**
             * @description A human-readable description of the booking.
             *
             * @example Booking 2345 for Clemens Gantert
             */
            summary?: string | null;
            /** Format: date-time */
            createdOn: string;
            passengers: components["schemas"]["Passenger"][];
            purchaser?: components["schemas"]["Purchaser"];
            /** @description Price of all unconfirmed pre-booked parts in the booking
             *      */
            provisionalPrice?: components["schemas"]["Price"];
            /** @description Sum of the refund amounts of all unconfirmed pre-booked refunds and exchanges
             *      */
            provisionalRefundAmount?: components["schemas"]["Price"];
            /** @description Sum of all prices of confirmed parts in the booking minus the sum of all confirmed refund amounts.
             *      */
            confirmedPrice?: components["schemas"]["Price"];
            bookedOffers?: components["schemas"]["BookedOffer"][];
            /** @description This trip will be included in the offer if the offer is part of the booking.
             *      */
            trips?: components["schemas"]["Trip"][];
            requestedInformation?: components["schemas"]["RequestedInformation"];
            /**
             * Format: date-time
             * @description Time until the booking needs to be confirmed or put on hold. After that, the booking is no longer valid.
             *
             */
            confirmationTimeLimit?: string | null;
            fulfillmentType?: components["schemas"]["FulfillmentType"];
            fulfillments?: components["schemas"]["Fulfillment"][];
            issuedVouchers?: components["schemas"]["VoucherInformation"][];
            documents?: components["schemas"]["Document"][];
            paymentMethods?: components["schemas"]["PaymentMethod"][];
            /** @description Refund offers are created with the details of the to-be-confirmed refund operation.
             *     One refund offer can then be confirmed, which turns it into a refund.
             *      */
            refundOffers?: components["schemas"]["RefundOffer"][];
            releaseOffers?: components["schemas"]["ReleaseOffer"][];
            cancelFulfillmentsOffers?: components["schemas"]["CancelFulfillmentsOffer"][];
            exchangeOperations?: components["schemas"]["ExchangeOperation"][];
            onHoldOffer?: components["schemas"]["OnHoldOffer"];
            /** @description If this booking has been split, this attribute references the newly created bookingIds.
             *      */
            relatedBookingIds?: string[] | null;
            /** @description Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        /** @description Request to cleanup a complete booking.
         *     Unconfirmed items will be deleted, any confirmed items will be refunded. There is no confirmation required.
         *      */
        BookingCleanupRequest: {
            overruleCode?: components["schemas"]["OverruleCode"];
            /**
             * Format: date-time
             * @description Indicates for passes the date taken as reference to compute possible partial refund. It is also the date taken
             *     as reference to invalidate the pass partially refunded.
             *
             */
            refundDate?: string | null;
        };
        BookingHistoryResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            events: components["schemas"]["Event"][];
        };
        /** @description References all the booking part elements in an uniform format.
         *     In its part, a BookingPartReference can refer to reservation, admission, ancillary or fee.
         *      */
        BookingPartReference: {
            id: string;
            /** @description A human-readable description of the booking part reference.
             *      */
            summary?: string | null;
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        /** @enum {string} */
        BookingPartStatus: "PREBOOKED" | "ON_HOLD" | "CONFIRMED" | "FULFILLED" | "CANCELLED" | "RELEASED" | "REFUNDED" | "EXCHANGE_ONGOING" | "EXCHANGED" | "ERROR";
        /** @enum {string} */
        FeeStatus: "PREBOOKED" | "CONFIRMED" | "REFUNDED";
        BookingPartSummary: {
            id: string;
            summary: string;
            productSummaries: components["schemas"]["ProductSummary"][];
            status: components["schemas"]["BookingPartStatus"];
            type: components["schemas"]["BookingPartType"];
        };
        /** @enum {string} */
        BookingPartType: "ADMISSION" | "RESERVATION" | "ANCILLARY";
        /** @description Allows setting the required fulfillment type, e.g. value paper
         *     or e-ticket and preferred fulfillment media.
         *     The latter is optional and relevant in some cases only.
         *      */
        BookingPatchRequest: {
            placeSelections?: components["schemas"]["PlaceSelection"][];
            requestedFulfillmentType?: components["schemas"]["FulfillmentType"];
            preferredFulfillmentMedia?: components["schemas"]["FulfillmentMediaType"];
            usedPaymentMethods?: components["schemas"]["PaymentMethod"][];
        };
        BookingRequest: {
            /** @description The list of offers that need to be provisionally booked, with possibly the reservations and ancillaries associated that should be booked as well.
             *      */
            offers: components["schemas"]["OfferSelection"][];
            /** @description If needed (cf requiredInformation) or desired, this array allows providing the required details on some or all passengers
             *      */
            passengerSpecifications: components["schemas"]["PassengerSpecification"][];
            purchaser?: components["schemas"]["PurchaserSpecification"];
            promotionCodes?: components["schemas"]["PromotionCode"][];
            /** @description Influences whether referenced resources are returned in full or as references only.
             *      */
            embed?: components["schemas"]["BookingResponseContent"][];
            externalRef?: string | null;
        };
        BookingResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            booking?: components["schemas"]["Booking"];
        };
        /**
         * @description Influences whether referenced resources are returned in full or as references only.
         *
         * @default ALL
         * @enum {string}
         */
        BookingResponseContent: "ALL" | "BOOKING" | "BOOKING_PASSENGERS" | "BOOKING_PURCHASER" | "BOOKING_TRIPS" | "BOOKING_BOOKEDOFFERS" | "BOOKING_FULFILLMENTS" | "BOOKING_DOCUMENTS" | "BOOKING_REFUNDOFFERS" | "BOOKING_RELEASEOFFERS" | "BOOKING_CANCELFULFILLMENTSOFFER" | "BOOKING_EXCHANGEOPERATIONS" | "NONE";
        BookingSearchParameters: {
            /**
             * Format: int32
             * @default 10
             */
            numberOfResults: number;
            status?: components["schemas"]["BookingPartStatus"][];
        };
        BookingSearchRequest: {
            origin?: components["schemas"]["PlaceRef"];
            destination?: components["schemas"]["PlaceRef"];
            passenger?: components["schemas"]["PersonSearchRequest"];
            purchaser?: components["schemas"]["PurchaserSearchRequest"];
            bookingId?: string | null;
            /** @description reference to the booking in the downstream distributor system
             *      */
            bookingCode?: string | null;
            /** @description reference to the booking in the retailer system */
            externalRef?: string | null;
            /**
             * @deprecated
             * @description reference to the booking in the downstream distributor system
             *
             */
            distributorBookingRef?: string | null;
            /** @deprecated */
            retailerBookingRef?: string | null;
            fulfillmentId?: string | null;
            fulfillmentControlNumber?: string | null;
            travelDateRange?: components["schemas"]["DateRange"];
            purchaseDateRange?: components["schemas"]["DateRange"];
            parameters?: components["schemas"]["BookingSearchParameters"];
        };
        BookingSearchResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            bookingSearchResults?: components["schemas"]["BookingSearchResult"][];
        };
        /** @description Summary of the booking found by the booking search. For more information, get the booking.
         *      */
        BookingSearchResult: {
            purchaser?: components["schemas"]["Purchaser"];
            passengers: components["schemas"]["Passenger"][];
            tripSummaries?: components["schemas"]["TripSummary"][];
            id: string;
            /** @description price of all unconfirmed pre-booked parts in the booking
             *      */
            provisionalPrice?: components["schemas"]["Price"];
            /** @description sum of the refund amounts of all unconfirmed pre-booked refunds and exchanges
             *      */
            provisionalRefundAmount?: components["schemas"]["Price"];
            /** @description sum of all prices of confirmed parts in the booking minus the sum of all confirmed refund amounts.
             *      */
            confirmedPrice?: components["schemas"]["Price"];
            bookedOfferSummaries: components["schemas"]["BookedOfferSummary"][];
        };
        /** @description Contains the newly created booking
         *      */
        BookingSplit: {
            bookingId: string;
            passengerIds: string[];
        };
        /** @description Group of passenger(s) that is to be split into a separate booking.
         *      */
        BookingSplitGroup: {
            passengerIds: string[];
        };
        BookingSplitRequest: {
            groups: components["schemas"]["BookingSplitGroup"][];
        };
        BookingSplitResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            bookingSplitResult?: components["schemas"]["BookingSplitResult"];
        };
        BookingSplitResult: {
            bookingSplit: components["schemas"]["BookingSplit"][];
        };
        Calendar: {
            /** Format: date-time */
            from?: string | null;
            /** Format: date-time */
            until?: string | null;
            /** @description dates included in the calendar. In case no dates are provided the range is assumed to be valid
             *      */
            dates?: string[] | null;
            /**
             * Format: int32
             * @description offset to UTC in minutes (number of minutes to be added to get UTC dates)
             *
             */
            utcOffset?: number | null;
        };
        CancelFulfillmentsOffer: {
            /** @description id of the cancel fulfillments offer
             *      */
            id: string;
            /** @description A human-readable description of the refund offer.
             *      */
            summary?: string | null;
            /** Format: date-time */
            createdOn: string;
            /** Format: date-time */
            validFrom: string;
            /**
             * Format: date-time
             * @description time until the offer can be used
             *
             */
            validUntil: string;
            /** Format: date-time */
            confirmedOn?: string | null;
            status: components["schemas"]["CancelFulfillmentsStatus"];
            fulfillments: components["schemas"]["Fulfillment"][];
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        CancelFulfillmentsOfferCollectionResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            cancelFulfillmentOffers?: components["schemas"]["CancelFulfillmentsOffer"][];
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        CancelFulfillmentsOfferPatchRequest: {
            status: components["schemas"]["CancelFulfillmentsStatus"];
        };
        CancelFulfillmentsOfferRequest: {
            fulfillmentIds?: components["schemas"]["FulfillmentId"][];
        };
        CancelFulfillmentsOfferResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            cancelFulfillmentsOffer?: components["schemas"]["CancelFulfillmentsOffer"];
        };
        /** @enum {string} */
        CancelFulfillmentsStatus: "PROPOSED" | "CONFIRMED";
        Car: {
            /** Format: int32 */
            weight: number;
            /** Format: int32 */
            length: number;
            /** Format: int32 */
            width: number;
            /** Format: int32 */
            height: number;
            /** @description Free text description of the model (e.g. BMW X5)
             *      */
            model: string;
            /** @description Indication of items attached to the car
             *      */
            attachedItems?: components["schemas"]["AttachableItemType"][];
            /** @description The license plate is a personal data item and must not be provided in an offer request.
             *     It must be patched into the offer after the customer accepted the offer for booking.
             *      */
            licensePlate?: string | null;
        };
        /** @description Number and issuer are needed to identify a travel account, the code identifies a reduction card.
         *      */
        CardReference: {
            /** @description Code of the card type according to issuer. E.g. BahnCard50.
             *     Predefined values from the [Reduction Card Code List](https://osdm.io/spec/catalog-of-code-lists/#ReductionCard)
             *      */
            code?: string | null;
            /** @description Number identifying the travel account, need issuer to be unique.
             *      */
            number?: string | null;
            issuer?: components["schemas"]["CompanyRef"];
            type: components["schemas"]["TravelAccountType"];
        };
        CardTypeReference: {
            issuer?: components["schemas"]["CompanyRef"];
            code: string;
            cardName?: string | null;
        };
        /** @description Either excluded or included carriers can be set.
         *      */
        CarrierConstraint: {
            includedCarriers?: string[] | null;
            excludedCarriers?: string[] | null;
        };
        /** @description Filter for in/exclusion of carriers. Provided by OJP.
         *      */
        CarrierFilter: {
            /**
             * @description Whether carrier in list are to include or exclude from search.
             *
             * @default true
             */
            exclude: boolean;
            /** @description Reference to carrier
             *      */
            carriers?: components["schemas"]["CompanyRef"][];
        };
        ClaimedJourneyDetails: {
            impact?: components["schemas"]["ImpactType"];
            /**
             * Format: duration
             * @example PT30M
             */
            finalDelay?: string | null;
            /** @default false */
            onReturn: boolean | null;
            delayedJourney?: components["schemas"]["ClaimedLeg"][];
        };
        ClaimedLeg: {
            trainNumber?: string | null;
            /** @description connection missed due to a delay on the previous leg
             *      */
            connectionMissed?: boolean | null;
            serviceDegradation?: components["schemas"]["ServiceDegradation"][];
            departureStation?: components["schemas"]["Place"];
            arrivalStation?: components["schemas"]["Place"];
            /** Format: date-time */
            plannedDepartureTime?: string | null;
            /** Format: date-time */
            timetabledArrivalTime?: string | null;
            /** Format: date-time */
            observedArrivalTime?: string | null;
        };
        Coach: {
            compartments?: components["schemas"]["Compartment"][];
            /** @description coach number
             *      */
            number: string;
            /** @description Id to identify the coach layout. In case of two deck vehicles,
             *     both upper and lower deck layouts are provided next to each other.
             *      */
            layoutId: string;
            /** @description id to identify a layout for the upper deck in a double deck coach
             *      */
            layoutIdUpperDeck?: string | null;
            /** @description id to identify a layout for the lower deck in a double deck coach
             *      */
            layoutIdLowerDeck?: string | null;
            direction?: components["schemas"]["TravelDirectionType"];
            owner?: components["schemas"]["CompanyRef"];
            specialCoach?: components["schemas"]["SpecialCoachType"];
            /** @description references to the reservations/fares for which all places in the coach can be selected. The reservation ids must be part of the list of reservation ids for which the consumer has requested the available places and the consumer must accept a list by setting singleSelectionMapsRequired to false
             *      */
            reservationRefs?: string[];
        };
        /** @description coach layout providing data to draw a coach layout. The items of a coach
         *     are located via coordinates with (0,0) in the upper left corner. All
         *     coordinates are given without sign.
         *      */
        CoachLayout: {
            /** @description id of this coachLayout on this server
             *      */
            id: string;
            /**
             * @description A human-readable description of the coach layout.
             *
             * @example Coach 3 in train T-122
             */
            summary?: string | null;
            /** @description list of places included in the layout
             *      */
            places?: components["schemas"]["CoachLayoutPlace"][];
            signs?: components["schemas"]["CoachLayoutSign"][];
            internals?: components["schemas"]["CoachLayoutInternal"][];
            compartmentNumbers?: components["schemas"]["CoachLayoutCompartmentNumber"][];
            gridSize: components["schemas"]["CoachLayoutGridSize"];
            /** @description Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        CoachLayoutCollectionResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            layouts?: components["schemas"]["CoachLayout"][];
        };
        CoachLayoutGridSize: {
            /** Format: int32 */
            x: number;
            /** Format: int32 */
            y: number;
        };
        CoachLayoutInternal: {
            /** @description Values from the [Graphics Items Code List](https://osdm.io/spec/catalog-of-code-lists/#GraphicsItems)
             *      */
            icon: string;
            mounting?: components["schemas"]["MountingType"];
            coords: components["schemas"]["LayoutCoordinates"];
        };
        CoachLayoutPlace: {
            /** @description Values from the [Graphics Items Code List](https://osdm.io/spec/catalog-of-code-lists/#GraphicsItems)
             *      */
            icon: string;
            /** @description place number as displayed physically on the place
             *      */
            number: string;
            direction?: components["schemas"]["DirectionType"];
            remarkId?: components["schemas"]["RemarkType"];
            coords: components["schemas"]["LayoutCoordinates"];
        };
        CoachLayoutResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            coachLayout?: components["schemas"]["CoachLayout"];
        };
        CoachLayoutSign: {
            /** @description Values from the [Graphics Items Code List](https://osdm.io/spec/catalog-of-code-lists/#GraphicsItems)
             *      */
            icon: string;
            direction?: components["schemas"]["DirectionType"];
            coords: components["schemas"]["LayoutCoordinates"];
        };
        /** @description Layout item to place a compartment number. The number has no icon, it only places the number */
        CoachLayoutCompartmentNumber: {
            number: string;
            coords: components["schemas"]["LayoutCoordinates"];
        };
        /** @description Tag to indicate that some products from a provider can be sold only when in conjunction
         *     with product(s) from another provider using the same tag. At least one, not all,
         *     combinationTags must be in common to allow combination. No combinationTags indicate
         *     that there are no combination constraints on the product.
         *      */
        CombinationTag: {
            id: string;
            /**
             * @description If false it means that this product can be sold also when not in conjunction with
             *     a product with the same tag. This is needed to propose specific products from one
             *     provider that depend on public ones of another.
             *
             * @default false
             */
            needsToBeCombined: boolean | null;
        };
        CompanyDetail: {
            name: string;
            registrationNumber: string;
            /**
             * @deprecated
             * @description Deprecated in favor of `legalPostalAddress`
             *
             */
            legalAddress?: components["schemas"]["Address"];
            legalPostalAddress?: components["schemas"]["PostalAddress"];
            taxId: string;
        };
        /** @description Identifies a company. For rail, a RICS company code or compatible ERA company code are used.
         *     E.g.: 'urn:uic:rics:1185:000011'
         *      */
        CompanyRef: string;
        /** @description Areas within a coach that holds places. Areas might be selectable
         *     as a whole. Usual areas would be classic compartments.
         *      */
        Compartment: {
            places: components["schemas"]["PlacePosition"][];
            /** @description Compartment number */
            number?: string;
            /**
             * @description Indicates whether compartments are selectable as a whole only
             *
             * @default false
             */
            isSelectable: boolean | null;
            /** @description references to the reservations/fares for which this place can be selected. The reservation ids must be part of the list of reservation ids for which the consumer has requested the available places and the consumer must accept a list by setting singleSelectionMapsRequired to false
             *      */
            reservationRefs?: string[];
            status?: components["schemas"]["AvailabilityStatus"];
            travelClass?: components["schemas"]["TravelClass"];
            serviceClass?: components["schemas"]["ServiceClassType"];
        };
        Complaint: {
            id: string;
            status: components["schemas"]["BackOfficeStatus"];
            customerComplaint?: components["schemas"]["CustomerComplaint"];
            /** @description indication of missing customer information
             *      */
            missingInformation?: string[] | null;
            decision?: components["schemas"]["ComplaintDecision"];
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        /** @description Known Values:
         *     - 'BANK_ACCOUNT'
         *     - 'SETTLED_TIME_LIMIT_EXCEEDED': A distributor settled the claim as the fare provided did not reply in due time. The compensation amount debited is provided.
         *     - 'PASSENGER_CHANGE'
         *      */
        ComplaintChangeReason: string;
        ComplaintDecision: {
            compensationAmount?: components["schemas"]["Price"];
            refundVoucher?: components["schemas"]["FulfillmentDocument"];
            explanation?: components["schemas"]["SupportingDocument"];
            shortExplanation?: string | null;
            /** @description Allocator or fare provider view on the delays. This might differ from the customer view.
             *      */
            delayedJourney?: components["schemas"]["Trip"][];
        };
        /** @description Changes to a claim already made.
         *     This covers upload of additional supporting documents, changes to  the passenger and claim manager data.
         *     The patch of the compensation amount requires an agreement between the involved parties and is used in
         *     case the legal time line for deciding the claim is passed.
         *      */
        ComplaintPatchRequest: {
            reason?: components["schemas"]["ComplaintChangeReason"];
            compensationAmount?: components["schemas"]["Price"];
            claimManager?: components["schemas"]["PersonDetail"];
            affectedPassengers?: components["schemas"]["Passenger"][];
            supportingDocuments?: components["schemas"]["SupportingDocument"][];
            bankAccount?: components["schemas"]["BankAccountReference"];
        };
        ComplaintResponse: {
            complaint: components["schemas"]["Complaint"];
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
        };
        /** @description Describes sales, usage and after sales conditions applicable to the product.  See after sales conditions for individual after sales amounts. The language of the text is controlled by the accept-language header, i.e. supporting English is a must.
         *      */
        Condition: {
            type: components["schemas"]["ConditionType"];
            /** @description human readable documentation of the text.
             *      */
            description: string;
            /** @description short description of the condition no longer than 64 characters
             *      */
            shortDescription?: string | null;
        };
        ConditionType: string;
        /** @description Contact information needed to contact a person. Either an email, a phone number or an address needs to be provided.
         *      */
        ContactDetail: {
            /** @description A human-readable description of the contact.
             *      */
            summary?: string | null;
            /** @description ISO-639-1 language code
             *      */
            preferredLanguage?: string | null;
            email?: string | null;
            /** @description Preferably a mobile phone number, to be contacted in case changes to the booking occur, e.g., in case of delays or interruptions .
             *      */
            phoneNumber?: string | null;
            /** @deprecated */
            address?: string | null;
            postalAddress?: components["schemas"]["PostalAddress"];
        };
        /** @enum {string} */
        ContextType: "OFFER" | "BOOKING";
        /** @description A leg of a journey that is not bound to a timetable. Provided by OJP.
         *      */
        ContinuousLeg: {
            start: components["schemas"]["Place"];
            end: components["schemas"]["Place"];
            service: components["schemas"]["ContinuousService"];
            /**
             * Format: date-time
             * @description Time at which window begins.
             *
             */
            timeWindowStart?: string | null;
            /**
             * Format: date-time
             * @description Time at which window ends.
             *
             */
            timeWindowEnd?: string | null;
            /**
             * Format: duration
             * @description Duration of this leg according to user preferences like walk speed.
             *
             * @example 1800S
             */
            duration?: string | null;
            situationFullRefs?: components["schemas"]["SituationFullRef"][];
            co2Emission?: components["schemas"]["Quantity"];
        };
        /** @description Types of modes that run at any time without a timetable. Provided by OJP.
         *      */
        ContinuousMode: string;
        /** @description A vehicle movement on a continuous, non-timetabled service.
         *     Service of this leg. May be 'walk' in most cases, but also cycling or taxi etc.
         *     Provided by OJP.
         *      */
        ContinuousService: {
            continuousMode?: components["schemas"]["ContinuousMode"];
            individualMode?: components["schemas"]["IndividualMode"];
            operatingDayRef: components["schemas"]["OperationDayRef"];
            journeyRef: components["schemas"]["JourneyRef"];
            /** @example Ask Stefan */
            mode: string;
            /** @example Circle Line */
            publishedServiceName: string;
            originText: string;
            destinationText: string;
        };
        /** @description Known Values:
         *     - 'SIP': secure paper tickets
         *     - 'SID': security in data (signed bar code)
         *     - 'SIS': security in system
         *     Values from the [Control Security Type Code List](https://osdm.io/spec/catalog-of-code-lists/#ControlSecurityType)
         *     Listed values here are examples.
         *      */
        ControlSecurityType: string;
        /** @description The corporate code is a token that reduces the price of an offer or enables  offers that are not available without it. Needs with a commercial agreement between parties.
         *      */
        CorporateCode: {
            /**
             * @description The corporate code issued by the referenced company.
             *
             * @example 123-232
             */
            code: string;
            /**
             * @description The name of the party that benefits from the corporate code, intended to be presented to the end user.
             *
             * @example Siemens
             */
            beneficiary?: string | null;
            issuer: components["schemas"]["CompanyRef"];
        };
        /**
         * @description ISO country code (2 alpha), relative URNs with base urn:iso:std:iso:3166 are recommended
         *
         * @example DE
         */
        CountryCode: string;
        /**
         * @description ISO 4217 currency codes
         *
         * @example CHF
         */
        Currency: string;
        /** @description complaint details provided by the passengers
         *      */
        CustomerComplaint: {
            /**
             * Format: date-time
             * @description date and time when the claim was made. This starts the legal time line to process the claim
             *
             */
            applicationTime?: string | null;
            journeyDetails?: components["schemas"]["ClaimedJourneyDetails"];
            claimManager?: components["schemas"]["PersonDetail"];
            affectedPassengers?: components["schemas"]["Passenger"][];
            supportingDocuments?: components["schemas"]["SupportingDocument"][];
            /** @description list of booking Ids
             *      */
            bookingIds?: string[] | null;
            /** @description list of ticket control number (visible ticket identification for the customer)
             *      */
            ticketControlNumber?: string[] | null;
            requestedPaymentType?: components["schemas"]["PaymentType"];
            bankAccount?: components["schemas"]["BankAccountReference"];
        };
        DateRange: {
            /** Format: date-time */
            startTime?: string | null;
            /** Format: date-time */
            endDate?: string | null;
        };
        /** @description Vehicle journey that runs at a specific date. Provided by OJP.
         *      */
        DatedJourney: {
            operatingDayRef?: components["schemas"]["OperationDayRef"];
            mode?: components["schemas"]["Mode"];
            productCategory?: components["schemas"]["ProductCategory"];
            /**
             * @description Line name or service description as known to the public, f.e. '512', 'S8'
             *     or 'Circle Line' or 'ICE 488'.
             *
             * @example S1
             */
            publishedServiceName?: string | null;
            vehicleNumbers: components["schemas"]["VehicleNumber"][];
            lineNumbers?: components["schemas"]["LineNumber"][];
            serviceStatus?: components["schemas"]["ServiceStatus"];
            situationFullRefs?: components["schemas"]["SituationFullRef"][];
            carriers: components["schemas"]["NamedCompany"][];
            attributes?: components["schemas"]["GeneralAttribute"][];
        };
        DayTravelAccountUnit: {
            objectType: "DayTravelAccountUnit";
        } & (Omit<components["schemas"]["AbstractTravelAccountUnit"], "objectType"> & Record<string, never>);
        /**
         * @description Direction of a place, defined optional as it might be omitted in
         *     case of berths in future.
         *     Code list according to UIC90918-1
         *     Valid Values:
         *     - RIGHT: to right
         *     - LEFT: to left
         *     - UP: up (from right side of a coach pointing to the middle of the aisle)
         *     - DOWN: down (from right side of the coach pointing to the middle of the aisle)
         *
         * @enum {string}
         */
        DirectionType: "RIGHT" | "LEFT" | "UP" | "DOWN";
        /** @description Non travel document created. Either downloadLink + downloadExpiry or content must be provided.
         *      */
        Document: {
            id: string;
            summary?: string | null;
            /** @description Reference to a passenger, to be specified when the document related to an individual passenger.
             *      */
            passengerRef?: string | null;
            /** Format: uri */
            downloadLink?: string | null;
            /**
             * Format: date-time
             * @description Expiration time of the download link, the document will not be available at the given URI  after this time.
             *
             */
            downloadExpiry?: string | null;
            /**
             * Format: byte
             * @description base64 encoded binary of the actual fulfillment document. The length restriction of 4 MBytes applies to the encoded
             *     string, so the raw document cannot exceed 3 MBytes in size.
             *
             */
            content?: string | null;
            format?: components["schemas"]["DocumentFormat"];
            type: components["schemas"]["DocumentType"];
            scope: components["schemas"]["DocumentScope"];
        };
        DocumentCollectionResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            documents: components["schemas"]["Document"][];
        };
        DocumentRequest: {
            document: components["schemas"]["DocumentSpecification"];
        };
        DocumentResponse: {
            warnings?: components["schemas"]["WarningCollection"];
            document?: components["schemas"]["Document"];
        };
        /** @enum {string} */
        DocumentScope: "BOOKING" | "PASSENGER";
        /** @description Non travel document created. Either downloadLink + downloadExpiry or content must be provided.
         *      */
        DocumentSpecification: {
            /** @description Reference to a passenger, to be specified when the document related to an individual passenger.
             *      */
            passengerRef?: string | null;
            /**
             * Format: byte
             * @description base64 encoded binary of the actual fulfillment document. The length restriction of 4 MBytes applies to the encoded
             *     string, so the raw document cannot exceed 3 MBytes in size.
             *
             */
            content?: string | null;
            format?: components["schemas"]["DocumentFormat"];
            scope: components["schemas"]["DocumentScope"];
            type: components["schemas"]["DocumentType"];
        };
        /** @enum {string} */
        DocumentType: "BOOKING_RECEIPT" | "CO2_REPORT" | "INFORMATION" | "COMPLAINT_EXPLANATION";
        /** @description Record of an action that occurred in the life cycle of the booking.
         *      */
        Event: {
            /** @description id of the event
             *      */
            id: string;
            /**
             * Format: date-time
             * @description timestamp of the event
             *
             */
            timestamp: string;
            type: components["schemas"]["EventType"];
            details: components["schemas"]["EventDetail"];
        };
        EventDetail: {
            /** @description human readable description of the event
             *      */
            summary: string;
            /** @description Contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
             *      */
            requestor: string;
            change: components["schemas"]["HistoryStatus"];
            resource: components["schemas"]["Resource"];
        };
        /** @enum {string} */
        EventType: "BOOKING_REAL_TIME_EVENT_OCCURRED" | "BOOKING_REACCOMMODATED" | "BOOKING_TRIP_CHANGED" | "BOOKING_TRIP_CONFIRMED" | "FULFILLMENT_AVAILABLE" | "DOCUMENT_AVAILABLE" | "FULFILLMENT_REFUNDED" | "FULFILLMENT_EXCHANGED" | "FULFILLMENT_CONTROLLED" | "ACCOMMODATION_RELEASED" | "PURCHASER_CHANGED" | "PASSENGER_CHANGED" | "REFUND_INITIATED" | "EXCHANGE_INITIATED";
        ExchangeOffer: {
            exchangeFee: components["schemas"]["Price"];
            /** @description Accounting information for the exchange fee
             *      */
            accountingRef?: components["schemas"]["AccountingRef"];
            exchangePrice: components["schemas"]["Price"];
            fulfillments: components["schemas"]["Fulfillment"][];
            offerId: string;
            /** @description A human-readable description of the offer.
             *      */
            summary?: string | null;
            offerSummary?: components["schemas"]["OfferSummary"];
            /** Format: date-time */
            createdOn: string;
            /**
             * Format: date-time
             * @description time until the offer can be pre-booked, however its availability is not guaranteed
             *
             */
            preBookableUntil: string;
            passengerRefs: string[];
            products?: components["schemas"]["Product"][];
            tripCoverage?: components["schemas"]["TripCoverage"];
            /** @description Breakdown of the exchange offer, including the exchange price, exchange fee, and refundable amount.
             *      */
            exchangeOfferBreakdown?: components["schemas"]["ExchangeBreakdownItem"][];
            admissionOfferParts: components["schemas"]["AdmissionOfferPart"][];
            reservationOfferParts?: components["schemas"]["ReservationOfferPart"][];
            ancillaryOfferParts?: components["schemas"]["AncillaryOfferPart"][];
            fees?: components["schemas"]["Fee"][];
            fares?: components["schemas"]["Fare"][];
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        ExchangeBreakdownItem: {
            exchangeFee: components["schemas"]["Price"];
            exchangePrice: components["schemas"]["Price"];
            refundableAmount?: components["schemas"]["Price"];
            bookingPartIds: string[];
        };
        /** @description Defines the parameters needed to request an exchange offer, either based on either an
         *     existing trip (that is then passed in) plus a set of offer search
         *     criteria, or based on trip-search and offer search criteria. At least one
         *     of the trip or tripSearchCriteria must be set.
         *      */
        ExchangeOfferCollectionRequest: {
            fulfillmentIds: string[];
            overruleCode?: components["schemas"]["OverruleCode"];
            tripSpecifications?: components["schemas"]["TripSpecification"][];
            tripIds?: string[] | null;
            tripSearchCriteria?: components["schemas"]["TripSearchCriteria"];
            nonTripSearchCriteria?: components["schemas"]["NonTripSearchCriteria"];
            requestedSections?: components["schemas"]["Section"][];
            offerSearchCriteria?: components["schemas"]["OfferSearchCriteria"];
            anonymousPassengerSpecifications: components["schemas"]["AnonymousPassengerSpecification"][];
            corporateCodes?: components["schemas"]["CorporateCode"][];
            promotionCodes?: components["schemas"]["PromotionCode"][];
            requestedFulfillmentOptions?: components["schemas"]["FulfillmentOption"][];
            embed?: components["schemas"]["OfferCollectionResponseContent"][];
        };
        ExchangeOfferCollectionResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            exchangeOffers?: components["schemas"]["ExchangeOffer"][];
            /** @description Two trips are returned if  round trips are exchanged.
             *      */
            trips?: components["schemas"]["Trip"][];
            passengers?: components["schemas"]["Passenger"][];
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        /**
         * @default ALL
         * @enum {string}
         */
        ExchangeOfferCollectionResponseContent: "ALL" | "EXCHANGEOFFERS" | "TRIP" | "PASSENGERS" | "NONE";
        ExchangeOperation: {
            id: string;
            status?: components["schemas"]["ExchangeStatus"];
            exchangeOffers?: components["schemas"]["ExchangeOffer"][];
            /** Format: date-time */
            ticketTimeLimit?: string | null;
            fulfillmentType?: components["schemas"]["FulfillmentType"];
            fulfillments?: components["schemas"]["Fulfillment"][];
            issuedVouchers?: components["schemas"]["VoucherInformation"][];
            trips?: components["schemas"]["Trip"][];
        };
        /** @description Allows modifying a general setting for the booking:
         *      * setting the required fulfillment type, e.g. value paper
         *        or e-ticket and preferred fulfillment media.
         *        The latter is optional and relevant in some cases only.
         *      * Provisionally exchanging some of the fulfillments in the booking
         *      */
        ExchangeOperationPatchRequest: {
            requestedFulfillmentType?: components["schemas"]["FulfillmentType"];
            preferredFulfillmentMedia?: components["schemas"]["FulfillmentMediaType"];
            /** @description Influences whether referenced resources are returned in full or as references only.
             *      */
            embed?: components["schemas"]["ExchangeOperationResponseContent"][];
        };
        ExchangeOperationRequest: {
            exchangeOffers: components["schemas"]["OfferSelection"][];
        };
        ExchangeOperationResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            exchangeOperation?: components["schemas"]["ExchangeOperation"];
        };
        /**
         * @description Influences whether referenced resources are returned in full or as references only.
         *
         * @default ALL
         * @enum {string}
         */
        ExchangeOperationResponseContent: "ALL" | "EXCHANGEOPERATION" | "EXCHANGEOPERATION_EXCHANGEOFFERS" | "EXCHANGEOPERATION_FULFILLMENTS";
        /** @enum {string} */
        ExchangeStatus: "PREBOOKED" | "CONFIRMED" | "FULFILLED" | "ERROR";
        /**
         * @description If set to YES the offerpart is exchangeable without a fee before the day of departure.
         *     NO when not exchangeable or exchangeable with 100% fee, WITH_CONDITIONS in all other cases.
         *
         * @enum {string}
         */
        ExchangeableType: "YES" | "NO" | "WITH_CONDITION";
        ExchangeOfferItem: {
            /** @description Amount kept by the carrier and/or the distributor */
            exchangeFee: components["schemas"]["Price"];
            exchangePrice: components["schemas"]["Price"];
            bookingParts: components["schemas"]["BookingPartReference"][];
        };
        /** @description time ranges excluded from the validity (e.g. off peak fulfillments)
         *      */
        ExcludedTimeRange: {
            /**
             * Format: int32
             * @description minutes of the day in the time zone of travel
             *
             */
            from: number;
            /**
             * Format: int32
             * @description minutes of the day in the time zone of travel
             *
             */
            until: number;
            scope: components["schemas"]["ExclusionScope"];
        };
        /** @enum {string} */
        ExclusionScope: "START_OF_TRAVEL" | "COMPLETE_RANGE";
        /** @description The online representation of a fare.
         *      */
        Fare: {
            /** @description id of the fare item to be included in accounting
             *      */
            id: string;
            type: components["schemas"]["FareType"];
            name?: components["schemas"]["Text"];
            description?: components["schemas"]["Text"];
            status?: components["schemas"]["BookingPartStatus"];
            /** @description allows specifying a price in multiple currencies
             *      */
            prices: components["schemas"]["Price"][];
            regionalConstraint: components["schemas"]["RegionalConstraint"];
            serviceConstraint?: components["schemas"]["ServiceConstraint"];
            carrierConstraint?: components["schemas"]["CarrierConstraint"];
            regulatoryConditions?: components["schemas"]["RegulatoryCondition"][];
            serviceClass?: components["schemas"]["ServiceClass"];
            travelClass: components["schemas"]["TravelClass"];
            afterSalesCondition: components["schemas"]["AfterSalesConditionsLink"];
            combinationConstraint: components["schemas"]["FareCombinationModel"][];
            fulfillmentConstraint?: components["schemas"]["FulfillmentConstraint"];
            travelValidityConstraint: components["schemas"]["TravelValidity"];
            availablePlaces?: components["schemas"]["AvailablePlace"][];
            placeSelection?: components["schemas"]["PlaceSelection"];
            placeAllocation?: components["schemas"]["PlaceAllocation"][];
            coveredSection?: components["schemas"]["Section"];
            passengerRefs?: string[];
            /** @description passenger constraint to be included in bar codes
             *      */
            passengerConstraints?: components["schemas"]["PassengerConstraints"][];
            involvedTCOs?: components["schemas"]["CompanyRef"][];
            legacyAccountingIdentifier?: components["schemas"]["LegacyAccountingIdentifier"];
            legacyReservationParameter?: components["schemas"]["LegacyReservationParameter"];
            /** @description One of the listed cards is required to be valid at the time of travel.
             *      */
            requiredCards: components["schemas"]["CardReference"][];
            luggageConstraint?: components["schemas"]["LuggageConstraint"];
            availablePreferences?: components["schemas"]["AvailablePlacePreferences"][];
        };
        /** @description Defines the model according to which the fares can be combined.
         *      */
        FareCombinationModel: {
            /** @description A distributor needs to support the following models:  SEPARATE_TICKET, SEPARATE_CONTRACT, CLUSTERING, COMBINING.
             *      */
            model: string;
            /** @description List of all carriers where the model can be applied, in case the list is empty
             *     all combinations are allowed.
             *      */
            combinableCarriers?: components["schemas"]["CompanyRef"][];
            /**
             * @description This combination model applies only in case the fare is combined with another carrier
             *
             * @default false
             */
            isValidOnlyWhenCombined: boolean | null;
            /** @description In case of CLUSTERING model: the cluster to which the fare belongs
             *      */
            referenceCluster?: string | null;
            /** @description In case of CLUSTERING model: the other clusters that allow a combination
             *      */
            allowedClusters?: string[] | null;
            /** @description List of carriers where a common contract with separate fulfillments are allowed.
             *      */
            allowedCommonContracts?: components["schemas"]["CompanyRef"][];
        };
        /** @description Connection point connecting two fare regimes. The connection is possible between stations of the two provided station sets.
         *     A legacy border point code (id) might be provided as an additional code within the stations (code list BORDER_POINT provided in URN).
         *     In case the connection point is a real station this station is indicated.
         *     In case the connection point is between stations for each side of the border real stations must be provided.
         *     Multiple sets of station can be provided in the rare case that the connection point connects more than two station (A-B and A-C).
         *     Multiple stations within a set at one side of the border might be provided in case of changes (new stations build near the border).
         *
         *     Providing the UIC code for the station is mandatory.
         *      */
        FareConnectionPoint: {
            objectType: "FareConnectionPoint";
        } & (Omit<components["schemas"]["Place"], "objectType"> & {
            name?: string | null;
            stationSets: components["schemas"]["StationSet"][];
            ref?: components["schemas"]["FareConnectionPointRef"];
        });
        /** @description Reference to a Fare Connection Point.
         *      */
        FareConnectionPointRef: {
            objectType: "FareConnectionPointRef";
        } & (Omit<components["schemas"]["PlaceRef"], "objectType"> & {
            name?: string | null;
        });
        /** @description Reference to a list of stations jointly valid in a fare. The fare
         *     reference station defines a set of station that are equivalent from
         *     a tariff point of view. The code is issued by the carrier. Needed to
         *     generate bar codes as well as fulfillments.
         *      */
        FareReferenceStation: {
            name: string;
            code: string;
            carrier: components["schemas"]["CompanyRef"];
            stations: components["schemas"]["StopPlaceRef"][];
        };
        /** @description Basic UIC fare types used in 90918-10, 90918-4, and 90918-9.
         *     Values from the [Fare Type Code List](https://osdm.io/spec/catalog-of-code-lists/#FareType)
         *     Listed values here are examples.
         *      */
        FareType: string;
        /** @description Fees are used to represent additional costs for services or products. In contrast to other offer parts in OSDM, the customer is not free whether to choose a fee or not: fees are generated and applied to other services or products by the providing system.
         *      */
        Fee: {
            id: string;
            /** @description A human-readable description of the fee.
             *      */
            summary?: string | null;
            price: components["schemas"]["Price"];
            applicability?: components["schemas"]["ApplicabilityType"];
            transactionContext?: components["schemas"]["TransactionContextType"];
            status?: components["schemas"]["FeeStatus"];
            /** @description reference to the booking in the downstream distributor system
             *      */
            distributorBookingRef?: string | null;
            refundable?: components["schemas"]["RefundType"];
            /** @description Structured description of the sales or after-sales conditions.
             *      */
            conditions?: components["schemas"]["Condition"][];
            /**
             * @deprecated
             * @description The product code expressed in the provider system (could be a
             *     mapping from an even lower-level provider).
             *
             */
            productCode?: string | null;
            /** @description Reference to the Product representing the Fee
             *      */
            productRef?: string;
            accountingRef?: components["schemas"]["AccountingRef"];
        };
        Flexibility: string;
        /** @description A fulfillment is a document (or part of a document in distributor mode) that
         *     - allows the passenger to prove its travel right
         *     - provides easier access to trains and stations
         *     - allows an exchange for other services (voucher)
         *     A fulfillment refers to services of one or multiple offer parts or a fare (distributor mode).
         *      */
        Fulfillment: {
            id: string;
            status: components["schemas"]["FulfillmentStatus"];
            /** @description the id of the booking the fulfillment is part of
             *      */
            bookingRef: string;
            /** @description A human-readable description of the fulfillment.
             *      */
            summary?: string | null;
            /** Format: date-time */
            createdOn: string;
            /** @description Ticket Control Number.
             *      */
            controlNumber?: string | null;
            bookingParts?: components["schemas"]["BookingPartReference"][];
            availableUsage?: components["schemas"]["FulfillmentUsage"];
            issuer?: components["schemas"]["CompanyRef"];
            /** @description Final document created for fulfillment.
             *      */
            fulfillmentDocuments?: components["schemas"]["FulfillmentDocument"][];
            /** @description the issuing language (ISO-639-1 language code). */
            issuingLanguage?: string;
            /** @description Fulfillment items to be integrated into tickets (distributor mode).
             *      */
            fulfillmentParts?: components["schemas"]["FulfillmentPart"][];
            tripCoverage?: components["schemas"]["TripCoverage"];
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        /** @description Changes the fulfillment to status AVAILABLE. In the case of multi-journey  product, one of the fulfillment is
         *     now 'activated' and can be used to travel.
         *      */
        FulfillmentActivationPatchRequest: {
            selectedZoneIds?: string[] | null;
            travelDates?: string[] | null;
            /** Format: date-time */
            startOfUsage: string;
            fromPlace?: components["schemas"]["PlaceRef"];
            /** @description The ids of the secure paper stock that identifies the blank secure paper stock used for printing.
             *
             *     The stock control number is only used for secure paper stock and triggers a printing of the stock control number in the ticket layout. This establishes a link between paper stock and ticket that is used to control the usage of blank secure paper stock at offices as secure paper has otherwise no intrinsic protection against internal fraud.
             *      */
            stockControlNumbers?: string[] | null;
        };
        FulfillmentCollectionResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            fulfillments?: components["schemas"]["Fulfillment"][];
            issuedVouchers?: components["schemas"]["VoucherInformation"][];
        };
        FulfillmentConstraint: {
            acceptedControlSecurityTypes: components["schemas"]["ControlSecurityType"][];
            /** @description for SiD fulfillment one of the listed bar codes is required
             *      */
            acceptedBarCodes?: components["schemas"]["BarCodeType"][];
            /** @description One of the listed bar codes must be provided.
             *      */
            requiredBarCodes?: components["schemas"]["BarCodeType"][];
            requiredSiS?: components["schemas"]["SiSType"][];
            /**
             * @description a separate fulfillment per passenger is forbidden
             *
             * @default false
             */
            isIndividualTicketingForbidden: boolean | null;
        };
        /** @description Document created for fulfillment. Either downloadLink + downloadExpiry or content must
         *     be provided.
         *      */
        FulfillmentDocument: {
            medium: components["schemas"]["FulfillmentMediaType"];
            type: components["schemas"]["FulfillmentDocumentType"];
            /** Format: uri */
            downloadLink?: string | null;
            /**
             * Format: date-time
             * @description Expiration time of the download link, the document will not be available at the given URI
             *     after this time.
             *
             */
            downloadExpiry?: string | null;
            /**
             * Format: byte
             * @description base64 encoded binary of the actual fulfillment document. The length restriction of 4 MBytes applies to the encoded
             *     string, so the raw document cannot exceed 3 MBytes in size.
             *
             */
            content?: string | null;
            format: components["schemas"]["DocumentFormat"];
        };
        /** @description The type of fulfillment document.
         *      */
        FulfillmentDocumentType: string;
        /**
         * @description Physical format of the document provided in the content field in Mime-Type format, e.g.
         *     application/pdf, image/jpeg, etc. Must be filled if the 'content' field is present.
         *
         * @enum {string}
         */
        DocumentFormat: "application/pdf" | "application/vnd.apple.pkpass" | "image/jpeg" | "image/png" | "text/calendar" | "text/html";
        FulfillmentId: string;
        FulfillmentItemSecurityFeature: {
            type?: components["schemas"]["SecurityFeatureType"];
            /**
             * Format: byte
             * @description base64 encoded data. The length restriction of 4 MBytes applies to the encoded
             *     string, so the raw data cannot exceed 3 MBytes in size.
             *
             */
            data?: string | null;
        };
        FulfillmentItemSecurityFeatureLinks: {
            type?: components["schemas"]["SecurityFeatureType"];
            /**
             * Format: uri
             * @description link to download the security feature
             *
             */
            uri?: string | null;
        };
        /** @description Fulfillment types. RCT2, RCCST and UIC_PDF are official UIC standards.
         *     Notice:`ALLOCATOR_APP` is deprecated and should not be used anymore. The `ALLOCATOR_APP` type is replaced by the `RETAILER_APP` type. `DISTRIBUTOR_APP` was introduced to distinguish between the different types of apps that can be used to fulfill a booking.
         *     Values from the [Fulfillment Media Type Code List](https://osdm.io/spec/catalog-of-code-lists/#FulfillmentMediaType)
         *     Listed values here are examples.
         *      */
        FulfillmentMediaType: string;
        /** @description CIT paper implies printing on value paper which is stock controlled.
         *      */
        FulfillmentOption: {
            type: components["schemas"]["FulfillmentType"];
            media: components["schemas"]["FulfillmentMediaType"];
        };
        /** @description Fulfillment items to be integrated in to tickets,
         *     e.g. visual security elements, additional bar codes, control keys.
         *      */
        FulfillmentPart: {
            /** @description list of fulfillment media where this item applies
             *      */
            fulfillmentMedia?: components["schemas"]["FulfillmentMediaType"][];
            /** @description reference to a passenger
             *      */
            passengerRef?: string | null;
            controlId?: string | null;
            /** @description 'visual elements, bar codes'
             *      */
            securityFeatures?: components["schemas"]["FulfillmentItemSecurityFeature"][];
            securityFeatureLinks?: components["schemas"]["FulfillmentItemSecurityFeatureLinks"][];
            fulfillmentInformationTexts?: components["schemas"]["TextElement"][];
            /**
             * @description The use of the provided features is mandatory.
             *
             * @default false
             */
            isMandatory: boolean | null;
            /**
             * @description The security feature must be used on secure paper.
             *
             * @default false
             */
            securePaperOnly: boolean | null;
        };
        /**
         * @description Individual fulfillments of a multi journey booking need an separate patch to create the usable fulfillment in status FULFILLED before they are in an intermediate state AVAILABLE where they don't provide a document for travel. Fulfillments can be ON_HOLD in case they are booked but not yet available (e.g. a booking providing two journeys per week) or passed in case the fulfillment was not patched for usage within the required time.
         *
         * @enum {string}
         */
        FulfillmentStatus: "AVAILABLE" | "ON_HOLD" | "CONFIRMED" | "FULFILLED" | "CHECKEDIN" | "CANCELLED" | "RELEASED" | "REFUNDED" | "EXCHANGED" | "EXPIRED";
        /** @description Changes the fulfillment to status FULFILLED.
         *      */
        FulfillmentPatchRequest: {
            fulfillmentUpdates?: components["schemas"]["FulfillmentId"][];
        };
        /** @description Creates the fulfillment in the requested language
         *      */
        FulfillmentPostRequest: {
            /** @description the desired issuing language (ISO-639-1 language code). If not provided or not available, will default to (one of) the language(s) of the issuing country */
            issuingLanguage?: string;
        };
        FulfillmentResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            fulfillment?: components["schemas"]["Fulfillment"];
        };
        /** @description Values from the [Fulfillment Type Code List](https://osdm.io/spec/catalog-of-code-lists/#FulfillmentType)
         *     Listed values here are examples.
         *      */
        FulfillmentType: string;
        /** @description In case of multi-journey products describe parameters to be used to change the a fulfillment in status AVAILABLE to FULFILLED so it can be used by the passenger.
         *      */
        FulfillmentUsage: {
            /** @default false */
            fromPlaceRequired: boolean | null;
            /** @description Travel dates that can be selected. Note: date only is used to cover properly the case of passes including
             *     multiple time zones.
             *      */
            travelDates?: string[] | null;
            travelValidityRanges?: components["schemas"]["TravelValidityRange"][];
            /**
             * Format: int32
             * @description upper limit to the number of selected zones
             *
             */
            maxAvailableZones: number;
            availableZones?: components["schemas"]["ZoneDefinition"][];
        };
        /**
         * @description The gender of the passenger, which is important in the case of night trains.
         *
         * @enum {string}
         */
        Gender: "MALE" | "FEMALE" | "X";
        GeneralAttribute: {
            text: string;
            code?: string | null;
            url?: string | null;
        };
        /** @description WGS84 coordinates position. Provided by OJP.
         *      */
        GeoPosition: {
            longitude: components["schemas"]["Longitude"];
            latitude: components["schemas"]["Latitude"];
        };
        /** @description Reference to a GeoPosition consisting of latitude and longitude.
         *      */
        GeoPositionRef: {
            objectType: "GeoPositionRef";
        } & (Omit<components["schemas"]["PlaceRef"], "objectType"> & {
            latitude: components["schemas"]["Latitude"];
            longitude: components["schemas"]["Longitude"];
        });
        /** @description granted reduction amounts
         *      */
        GrantedReductionAmounts: {
            grantedReductionAmount?: components["schemas"]["GrantedReductionAmount"][];
        };
        /** @description Applied passenger types and reductions per passenger, per offerpart, booking part and per part of the trip.
         *     Passengers might be omitted in case the reduction applies to the complete booking part.
         *      */
        GrantedReductionAmount: {
            /** @description Clear text representation of the actual passenger type, suitable to be presented to a client.
             *      */
            description: string;
            grantedAmount: components["schemas"]["Price"];
            /** @description ids of the passengers that were granted the reduction
             *      */
            passengerRefs?: string[];
            tripCoverage?: components["schemas"]["TripCoverage"];
            appliedPassengerTypes?: components["schemas"]["ActualPassengerType"][];
            appliedReductions?: components["schemas"]["CardReference"][];
            appliedCorporateCodes?: components["schemas"]["CorporateCode"][];
            appliedPromotionCodes?: components["schemas"]["PromotionCode"][];
        };
        /** @enum {string} */
        HistoryStatus: "PREBOOKED" | "ON_HOLD" | "CONFIRMED" | "FULFILLED" | "CANCELLED" | "RELEASED" | "REFUNDED" | "EXCHANGED" | "EXCHANGE_ONGOING" | "ERROR" | "AVAILABLE" | "CHECKED_IN";
        /** @description Person identification information  to be exchanged for border control if legally required.
         *
         *     It is not allowed to send personal information not required in the offer reply.
         *     It is legally not allowed to send these personal data already in the offer request.
         *      */
        IdentificationCard: {
            /** @description Identifier on the document.
             *      */
            id: string;
            /** @description Refer to code list for values
             *      */
            type: string;
            /** @description ICAO transliteration identical as written in the document
             *      */
            name?: string | null;
            /** @description ISO 3166 2A codes
             *      */
            nationality?: string | null;
            birthCity?: string | null;
            /** @description place where the document is issued
             *      */
            issuingCity?: string | null;
            residenceCity?: string | null;
            birthCountryCode?: components["schemas"]["CountryCode"];
            issuingCountryCode?: components["schemas"]["CountryCode"];
            residenceCountryCode?: components["schemas"]["CountryCode"];
            /** Format: date-time */
            issuingDate?: string | null;
            gender?: components["schemas"]["Gender"];
            /** Format: date */
            expirationDate?: string | null;
        };
        /** @description Known Values:
         *     - DELAY: delayed arrival
         *     - JOURNEY_ABANDONED: trip way abandoned during the travel
         *     - JOURNEY_NOT_STARTED: trip was not started due to the delay
         *     - SERVICE_DEGRADED: e.g. service class not provided
         *      */
        ImpactType: string;
        IndicatedConsumption: {
            unit?: components["schemas"]["AbstractTravelAccountUnit"];
            /** Format: int32 */
            amount: number;
        };
        IndicatedTravelAccountConsumption: {
            /** Format: int32 */
            amount: number;
            /**
             * Format: int32
             * @default 2
             */
            scale: number;
        };
        /** @description Modes which an individual powers themselves (such as walk, cycle). Provided by OJP.
         *      */
        IndividualMode: string;
        /** @description Initial input for the place information request. This input defines what is originally looked for.
         *     Provided by OJP.
         *      */
        InitialPlaceInput: {
            /**
             * @description Name of the place object which is looked after. This is usually the user's input. If not given,
             *     the name of the resulting place objects is not relevant.
             *
             * @example Bern Bärengraben
             */
            name?: string | null;
            geoPosition?: components["schemas"]["GeoPosition"];
        };
        /** @description Describes the situation at a stop or station that lies between the Board and
         *     Alight stop or station including time-related information. Provided by OJP.
         *      */
        Intermediate: {
            stopPlaceRef: components["schemas"]["StopPlaceRef"];
            /** @example Luzern */
            stopPlaceName: string;
            /**
             * @description Name of the bay/quay/terminal where to board/alight from the vehicle. According to
             *     planned timetable.
             *
             * @example 3
             */
            plannedStopPointName?: string | null;
            /**
             * @description Name of the bay/quay/terminal where to board the vehicle. As to the latest realtime status.
             *
             * @example 8
             */
            estimatedStopPointName?: string | null;
            serviceArrival: components["schemas"]["ServiceTime"];
            serviceDeparture: components["schemas"]["ServiceTime"];
            status?: components["schemas"]["StopCallStatus"];
        };
        /** @description Minimal intermediate specification.
         *      */
        IntermediateSpecification: {
            stopPlaceRef: components["schemas"]["StopPlaceRef"];
            serviceArrival: components["schemas"]["ServiceTime"];
            serviceDeparture: components["schemas"]["ServiceTime"];
        };
        /**
         * @description Reference to a journey. Provided by OJP.
         *
         * @example ServiceJourney:1
         */
        JourneyRef: string | null;
        /**
         * Format: double
         * @description Latitude from equator. -90 (South) to +90 (North). Decimal degrees. e.g. 56.356.
         *
         * @example 47.37818
         */
        Latitude: number;
        LayoutCoordinates: {
            /**
             * Format: int32
             * @description horizontal coordinate of the center of the place
             *
             */
            x: number;
            /**
             * Format: int32
             * @description vertical coordinate of the center of the place
             *
             */
            y: number;
            /**
             * Format: int32
             * @description Graphical layer where this item has to be placed.
             *     Code list according to UIC90918-1
             *       - value 0: lowest layer usually used for walls
             *       - value 1: middle layer usually used by places
             *       - value 2: top layer usually used by icons
             *
             */
            zOrder: number;
        };
        /** @description Attributes that are not valid on the whole service, but only on section of a trip made on a single mode without interchange between boarding and alighting.
         *      */
        LegAttribute: {
            /** @description Text of the attribute to be shown to the user.
             *      */
            text: string;
            /** @description Internal code of the attribute. Can be used for detection of double occurrences. Refers to Service Facilities / Leg Attributes from the Catalog of Code Lists
             *      */
            code?: string | null;
            /**
             * Format: int32
             * @description The attribute is valid from the stop point with this sequence number within the leg. If missing it is valid from the beginning of the leg.
             *
             */
            fromStopSeqNumber?: number | null;
            /**
             * Format: int32
             * @description The attribute is valid to the stop point (inclusively) with this sequence number within the leg. If missing it is valid to the end of the leg.
             *
             */
            toStopSeqNumber?: number | null;
        };
        /** @description identifier of the fare in the current 301 accounting file
         *      */
        LegacyAccountingIdentifier: {
            /**
             * Format: int32
             * @description sequential number of regional validities
             *
             */
            serialId: number;
            /**
             * Format: int32
             * @description Sequential number of regional validities (leading positions in case the series
             *     is too short).
             *
             */
            addId?: number | null;
            /**
             * Format: int32
             * @description Tariff id for the old series format.
             *
             */
            tariffId?: number | null;
        };
        /** @description reservation parameter to support the UIC 90918-1 interface for booking
         *      */
        LegacyReservationParameter: {
            /** @description 90918-1 class code in reservation
             *      */
            travelClass: string;
            /** @description service level code defined in UIC 90918-1
             *      */
            serviceLevelCode: string;
            /** @description service code to be used in reservation
             *      */
            serviceCode: string;
            /** @description berth type code in UIC 90918-1 to be used in reservation
             *      */
            berthType?: string | null;
            /** @description coach type code in UIC 90918-1 to be used in reservation
             *      */
            coachTypeCode?: string | null;
            /** @description compartment type code in UIC 90918-1 to be used in reservation
             *      */
            compartmentTypeCode?: string | null;
            /** @description tariff according to UIC 90918-1 to be used for booking
             *      */
            tariffs?: components["schemas"]["LegacyReservationTariff"][];
        };
        /** @description Legacy tariff code and number of items or persons in case UIC 90918-1 is used for booking.
         *      */
        LegacyReservationTariff: {
            /**
             * Format: int32
             * @description number of items with this tariff code
             *
             */
            number?: number | null;
            /**
             * Format: int32
             * @description legacy tariff code
             *
             */
            code?: number | null;
        };
        /** @description terminalStation - in case the product requires a destination within the zone (e.g. local ticket
         *     to go to the main rail station).
         *     entryStation - Station to enter the zone in case the product requires to enter the zone via a
         *     specific station (e.g. local zone ticket to start from the main rail station).
         *      */
        Line: {
            /**
             * Format: byte
             * @description Id to support local traffic standards (e.g. VDV,...).
             *
             */
            binaryLineId?: string | null;
            carrier: components["schemas"]["CompanyRef"];
            /** Format: int32 */
            city?: number | null;
            entryStation?: components["schemas"]["StopPlace"];
            lineIds?: string[] | null;
            terminalStation?: components["schemas"]["StopPlace"];
            /** @description Nomenclature des units territoriales statistiques
             *      COMMISSION REGULATION (EU) No 31/2011
             *      */
            nutsCode?: string | null;
        };
        /**
         * @description Especially on regional traffic, a vehicle is defined by a line number.
         *     E.g. the line numbers of 'S 52' or 'B 19'.
         *
         * @example 52, 19
         */
        LineNumber: string | null;
        /** @description The underlying system may provide links for pagination of links pointing on
         *     further information (such as HTML download links, web sites or extended APIs).
         *     Mechanism to add flexible extensions specific to an underlying system. Implemented
         *     the JSON-HAL specification.
         *      */
        Link: {
            /**
             * @description the 'rel' field in HATEOAS navigation.
             *
             * @example self
             */
            rel: string;
            /**
             * Format: uri
             * @description Allows to provide a value to the link, for example id of the targeted resource or displayable representation for the link.
             *
             */
            href: string;
            /**
             * @description Hint to indicate the media type expected when dereferencing the target resource.
             *
             * @example application/json
             */
            type?: string | null;
            /** @description Allows to provide a value to the link, for example id of the targeted resource or displayable representation for the link.
             *      */
            value?: string | null;
        };
        /**
         * Format: double
         * @description Longitude from Greenwich Meridian. -180 (West) to +180 (East). Decimal degrees. eg 2.356.
         *
         * @example 8.54021
         */
        Longitude: number;
        /** @description Constraint on the luggage allowed by a passenger to on board.
         *      */
        LuggageConstraint: {
            /**
             * Format: int32
             * @description standard hand luggage pieces
             *
             */
            maxHandLuggage?: number | null;
            /**
             * Format: int32
             * @description standard non-hand luggage pieces
             *
             */
            maxLargeLuggage?: number | null;
            restrictions?: components["schemas"]["LuggageRestriction"][];
            restrictionRules?: components["schemas"]["LuggageRestrictionRuleEnum"][];
        };
        LuggageDimension: {
            dimension: components["schemas"]["LuggageDimensionEnum"];
            /** @description Value of the dimension: weight in kg, length in cm, volume in liter.
             *      */
            value: string;
        };
        /**
         * @description Type of the dimension. Combined sizes are the sum of the sizes.
         *
         *     Explanation:  WIDTH_HEIGHT_LENGTH = sum of width, hight and length in cm (= linear equivalent).
         *
         * @enum {string}
         */
        LuggageDimensionEnum: "HEIGHT" | "LENGTH" | "WEIGHT" | "WIDTH" | "WIDTH_HEIGHT" | "WIDTH_HEIGHT_LENGTH" | "VOLUME";
        LuggageRestriction: {
            /** @description The dimension apply to the luggage items as upper limits.
             *      */
            dimensionRestrictions: components["schemas"]["LuggageDimension"][];
            /**
             * Format: int32
             * @description Number of luggage items allowed with this restriction.
             *
             */
            numberOfItems: number;
            /** @description The registrationIds to be included in a bar code on the fulfillment (UIC IRS 90918-4) (e.g. on a luggage tag).
             *      */
            registrationIds?: string[] | null;
        };
        /**
         * @description Named luggage restriction rule.
         *
         *     Valid Values:
         *     - CAN_CARRY: Weight is ok if you can carry it yourself.
         *
         * @enum {string}
         */
        LuggageRestrictionRuleEnum: "CAN_CARRY";
        /** @description A method of transportation such as bus, rail, etc. Provided by OJP.
         *      */
        Mode: {
            ptMode: components["schemas"]["PTMode"];
            /**
             * @description Name of the mode
             *
             * @example rail
             */
            name?: string | null;
            /**
             * @description Short name or acronym of the mode
             *
             * @example S
             */
            shortName?: string | null;
            /** @description Additional text that further describes the mode
             *      */
            description?: string | null;
        };
        /** @description List of public transport modes to include or exclude. Provided by OJP.
         *      */
        ModeFilter: {
            /**
             * @description Whether modes in list are to include or exclude from search.
             *
             * @default true
             */
            exclude: boolean;
            /** @description List of Transport modes to include/exclude.
             *      */
            transportModes?: components["schemas"]["Mode"][];
        };
        MoneyTravelAccountUnit: {
            objectType: "MoneyTravelAccountUnit";
        } & (Omit<components["schemas"]["AbstractTravelAccountUnit"], "objectType"> & {
            currency: components["schemas"]["Currency"];
            /**
             * Format: int32
             * @default 2
             */
            scale: number;
        });
        MotorCycle: {
            /** @default false */
            isSideCarIncluded: boolean | null;
            /** @description The license plate is a personal data item and must not be provided in an offer request.
             *     It must be patched into the offer after the customer accepted the offer for booking
             *      */
            licensePlate?: string | null;
        };
        /** @enum {string} */
        MountingType: "UPPER_BORDER" | "LOWER_BORDER" | "UPPER_TO_LOWER_BORDER" | "FREE";
        MultiRideAccount: {
            objectType: "MultiRideAccount";
        } & (Omit<components["schemas"]["AbstractTravelAccount"], "objectType"> & {
            regionalConstraint?: components["schemas"]["RegionalConstraint"];
            regionalConstraintSummary: string;
            balance: components["schemas"]["MultiRideBalance"];
            consumptions?: components["schemas"]["TravelAccountConsumption"][];
        });
        /** @description The balance of the travel account.
         *      */
        MultiRideBalance: {
            /** Format: int32 */
            total: number;
            /** Format: int32 */
            remaining: number;
            unit: components["schemas"]["AbstractTravelAccountUnit"];
        };
        /** @description Provides the reference and name of a company.
         *      */
        NamedCompany: {
            ref: components["schemas"]["CompanyRef"];
            /**
             * @description Textual representation of the carrier to be displayed unless the application is able to indicate the name by the carrier references.
             *
             * @example RhB
             */
            name?: string | null;
        };
        NamedTravelAccountUnit: {
            objectType: "NamedTravelAccountUnit";
        } & (Omit<components["schemas"]["AbstractTravelAccountUnit"], "objectType"> & {
            name: string;
        });
        /** @description Defines the requested validity when searching specifically for a non-trip Offer.
         *
         *     The geographical validity can either be specified by a list of nutsCodes, by a list of places (e.g. stations) with the semantics that trips between either of any of the listed stations are covered (e.g. Frankfurt (Main) Hbf, Friedberg(Hess) and Hanau Hbf, which would imply that any travel between these stations is to be covered), or a list of zones (e.g. with carrier urn:vdv:rmv, the zones with the ids 50, 2501 and 3001 would cover the same area as the list of stations above).
         *      */
        NonTripSearchCriteria: {
            /** Format: date-time */
            validFrom?: string | null;
            /** @description Nomenclature des units territoriales statistiques COMMISSION REGULATION (EU) No 31/2011
             *      */
            nutsCodes?: string[] | null;
            zones?: components["schemas"]["ZoneDefinition"][];
            places?: components["schemas"]["PlaceRef"][];
        };
        /** @description Not-via restrictions for a trip, i.e. scheduled stop points or stop places that the trip is not allowed to pass through.  Provided by OJP.
         *      */
        NotVia: {
            notViaPlace?: components["schemas"]["PlaceRef"][];
        };
        Offer: {
            offerId: string;
            /** @description A human-readable description of the offer.
             *      */
            summary?: string | null;
            offerSummary?: components["schemas"]["OfferSummary"];
            /** Format: date-time */
            createdOn: string;
            /**
             * Format: date-time
             * @description time until the offer can be pre-booked, however its availability is not guaranteed
             *
             */
            preBookableUntil: string;
            passengerRefs: string[];
            products?: components["schemas"]["Product"][];
            tripCoverage?: components["schemas"]["TripCoverage"];
            admissionOfferParts?: components["schemas"]["AdmissionOfferPart"][];
            reservationOfferParts?: components["schemas"]["ReservationOfferPart"][];
            ancillaryOfferParts?: components["schemas"]["AncillaryOfferPart"][];
            fees?: components["schemas"]["Fee"][];
            fares?: components["schemas"]["Fare"][];
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        /** @description Defines the parameters needed to request an offer. Either a tripSearchCriteria, a list of trip specifications, or a list of tripIds can be passed in to request offers.
         *
         *     If you are searching for fares you pass in the complete trip and the use the requestedSections attribute to define which part(s) you need fares (including virtual border points).
         *      */
        OfferCollectionRequest: {
            tripSpecifications?: components["schemas"]["TripSpecification"][];
            tripIds?: string[] | null;
            tripSearchCriteria?: components["schemas"]["TripSearchCriteria"];
            nonTripSearchCriteria?: components["schemas"]["NonTripSearchCriteria"];
            requestedSections?: components["schemas"]["Section"][];
            offerSearchCriteria?: components["schemas"]["OfferSearchCriteria"];
            anonymousPassengerSpecifications: components["schemas"]["AnonymousPassengerSpecification"][];
            corporateCodes?: components["schemas"]["CorporateCode"][];
            promotionCodes?: components["schemas"]["PromotionCode"][];
            requestedFulfillmentOptions?: components["schemas"]["FulfillmentOption"][];
            /** @description Influences whether referenced resources are returned in full or as references only. Proposed default ALL
             *      */
            embed?: components["schemas"]["OfferCollectionResponseContent"][];
        };
        OfferCollectionResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            offers?: components["schemas"]["Offer"][];
            anonymousPassengerSpecifications?: components["schemas"]["AnonymousPassengerSpecification"][];
            trips?: components["schemas"]["Trip"][];
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        /**
         * @default ALL
         * @enum {string}
         */
        OfferCollectionResponseContent: "ALL" | "OFFERS" | "TRIPS" | "NONE";
        /**
         * @description Offer mode applied to provide offers for given criteria.
         *
         *     Individual offer mode means that each passenger is given individual admissions and reservations  to allow to refund individual passengers booked in a single booking.
         *
         *     If collective mode is not supported,  reverts back to the other mode and provides warning instead.
         *
         * @enum {string}
         */
        OfferMode: "COLLECTIVE" | "INDIVIDUAL";
        /** @description References all the offer part elements in an uniform format.
         *     In its part, an OfferPartReference can refer to reservation, admission, ancillary or fee.
         *      */
        OfferPartReference: {
            id: string;
            /** @description A human-readable description of the offer part reference.
             *      */
            summary?: string | null;
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        /**
         * @description Allows to request offer-parts of a certain type.
         *     To support H/H use ['RESERVATION', 'ANCILLARY'].
         *     Default is to get search for offers of all types.
         *
         * @enum {string}
         */
        OfferPartType: "ADMISSION" | "RESERVATION" | "ANCILLARY" | "FARE_ADMISSION" | "FARE_RESERVATION" | "FARE_ANCILLARY" | "ALL";
        OfferSearchCriteria: {
            requestedOfferParts?: components["schemas"]["OfferPartType"][];
            productTags?: components["schemas"]["ProductTag"][] | null;
            /** @description Defines the flexibility levels desired of the fares returned.
             *     This refers to the after sales flexibility levels as defined in IRS-90918-10
             *      */
            flexibilities?: components["schemas"]["Flexibility"][];
            /** @description The classes returned might be different from the requested classes.
             *      */
            travelClasses?: components["schemas"]["TravelClass"][];
            /** @description The classes returned might be different from the requested classes.
             *      */
            serviceClassTypes?: components["schemas"]["ServiceClassType"][];
            offerMode?: components["schemas"]["OfferMode"];
            currency?: components["schemas"]["Currency"];
        };
        /** @description The Ids of the offers to be booked need to be passed in.
         *      */
        OfferSelection: {
            /** @description id of the selected offer or exchangeOffer
             *      */
            offerId: string;
            /** @description A stable reference to the id of the offer in the caller's system. When received in input of a request, it must be persisted and echoed back in the response.
             *      */
            externalRef?: string;
            /** @description Mandatory reservations are booked when the booking is being booked.
             *      */
            optionalReservationSelections?: components["schemas"]["ReservationSelection"][];
            optionalAncillarySelections?: components["schemas"]["AncillarySelection"][];
            placeSelections?: components["schemas"]["PlaceSelection"][];
            /**
             * @description in case the distributor has proposed this offer in conjunction with an offer of another provider constrained
             *     by a combinationTag, this flag must be set to true to indicate to the provider that after-sale must be done
             *     on the totality of the distributor's booking. Only after-sale requests triggered by the distributor can be
             *     safely processed on this offer. When the flag is not set, standard provider logic applies.
             *
             * @default false
             */
            afterSaleByRetailerOnly: boolean | null;
            appliedRegulatoryCondition?: components["schemas"]["RegulatoryCondition"];
            passengerRefs: string[];
            throughTicketTags?: components["schemas"]["ThroughTicketTag"][];
        };
        /** @description The offer summary indicates the most relevant service class, level, flexibility or accommodation
         *     that describe this offer, but this does not imply that these values exactly apply to all parts of
         *     the offer.
         *     Let's consider, as a simplified example, a trip composed of two legs, one with both 1st and
         *     2nd class, and one with only 2nd.
         *     On this trip, the railway is expected to propose one offer with overallServiceClass FIRST composed
         *     of one admission in 1st class on the first legs and one admission in 2nd class on the second one,
         *     plus a second offer with overallServiceClass SECOND composed of two second class admissions.
         *     Likewise for all 'overall' attributes. The purpose of these attributes is to convey to the client
         *     system the service class, level, flexibility and accommodation that best represent this offer so to
         *     facilitate presentation to the final user.
         *      */
        OfferSummary: {
            minimalPrice: components["schemas"]["Price"];
            overallServiceClass: components["schemas"]["ServiceClass"];
            overallTravelClass?: components["schemas"]["TravelClass"];
            overallAccommodationType?: components["schemas"]["AccommodationType"];
            overallAccommodationSubType?: components["schemas"]["AccommodationSubType"];
            overallFlexibility: components["schemas"]["Flexibility"];
            minimalIndicatedConsumption?: components["schemas"]["IndicatedConsumption"];
        };
        /** @description The offerTag can/must (depending on the mandatory flag) be used in some cases to restrict the
         *     set of offers returned in a subsequent and related offer search to only compatible ones.
         *     Note the offerTag does not need to be unique.
         *      */
        OfferTag: {
            id?: string | null;
            /** @default false */
            isMandatory: boolean | null;
        };
        OnHoldOffer: {
            id: string;
            summary: string;
            /** Format: date-time */
            createdOn: string;
            /** Format: date-time */
            validFrom: string;
            /** Format: date-time */
            validUntil: string;
            /** Format: date-time */
            confirmedOn?: string | null;
            onHoldFee: components["schemas"]["Fee"];
            deposit: components["schemas"]["Price"];
            /**
             * Format: date-time
             * @description Increased time-to-live.
             *
             */
            increasedTTL: string;
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        OnHoldOfferPatchRequest: Record<string, never>;
        /** @description Confirming the offer puts into the 'On-hold' state.
         *      */
        OnHoldOfferRequest: {
            /**
             * Format: int32
             * @description increase of time to live (in minutes)
             *
             */
            increaseTTL: number;
        };
        OnHoldOfferResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            onHoldOffer?: components["schemas"]["OnHoldOffer"];
        };
        /** @description Day of public transport operation of which the characteristics are defined in a specific
         *     service calendar and which may last more than 24 hours. Provided by OJP.
         *      */
        OperatingDays: {
            /**
             * Format: date-time
             * @description Start date of period
             *
             */
            from: string;
            /**
             * Format: date-time
             * @description End date of period
             *
             */
            until: string;
            /** @description Bit pattern for operating days between start date and end date.
             *     The length of the pattern is equal to the number of days from
             *     start date to end date. A bit value of '1' indicates that an event
             *     actually happens on the day that is represented by the bit position.
             *      */
            pattern: string;
        };
        /**
         * @description Reference to an operating day. Provided by OJP.
         *
         * @example OperatingDay:12345
         */
        OperationDayRef: string | null;
        /** @description Structure of an Open Street Map tag. Provided by OJP.
         *      */
        OsmTag: {
            /**
             * @description Name of Open Street Map tag (amenity, leisure, tourism, bike, ...)
             *
             * @example name
             */
            tag: string;
            /**
             * @description Value for Open Street Map tag (charging_station, hostel, yes, ...)
             *
             * @example Rozenrust
             */
            value: string;
        };
        /** @description Reason for and type of an after sale, code list in IRS 90918-10.
         *     The PRM_SUPPORT_UNAVAILABLE overrule code shall only be used by the UIC PRM ABT tool.
         *     Values from the [Overrule Codes Code List](https://osdm.io/spec/catalog-of-code-lists/#OverruleCode)
         *     Listed values here are examples.
         *     - 'CONNECTION_BROKEN'
         *     - 'DEATH'
         *     - 'EQUIPMENT_FAILURE'
         *     - 'PAYMENT_FAILURE'
         *     - 'PRM_SUPPORT_UNAVAILABLE'
         *     - 'SALES_STAFF_ERROR'
         *     - 'STOP_NOT_SERVED'
         *     - 'STRIKE'
         *     - 'TECHNICAL_FAILURE'
         *     - 'TICKET_NOT_USED'
         *     - 'INABILITY_TO_TRAVEL': Inability to travel due to accident or sickness.
         *     - 'EXTERNAL_COMPENSATION': Offer has been compensated outside of the provider system in another way.
         *     - 'DISRUPTION': Inability to operate due to disruption.
         *     - 'JOURNEY_OBSOLETE': Due to external factors it's senseless to start the trip, thus the travel is obsolete.
         *     - 'CERTIFIED_MEDICAL_CONDITION': A medical certificate certifies that the passenger is unable to travel.
         *     - 'DELAY_COMPENSATION': Allows to override conditions in context of passenger rights regulation (PRR).
         *      */
        OverruleCode: string;
        PRMNeedType: string;
        /** @description TAP-TSI/UIC contains a sensible subset of SIRI Transport Modes.
         *     Values from the [Transport Mode Code List](https://osdm.io/spec/catalog-of-code-lists/#TransportMode)
         *     Listed values here are examples.
         *      */
        PTMode: string;
        /** @description Information about a passenger.
         *
         *     Either the date of birth or the age at the time of travel needs to be set. We recommend to use date of birth as it is more stable than age.
         *      */
        Passenger: {
            id: string;
            /** @description A human-readable description of the passenger.
             *      */
            summary?: string | null;
            /** @description A stable reference to a passenger from other elements, or from caller system.
             *     When passed in passenger specification in an offer request, it must be echoed back in the
             *     response.
             *      */
            externalRef: string;
            /**
             * Format: date
             * @description date of birth of the passenger
             *
             */
            dateOfBirth?: string | null;
            /** Format: int32 */
            age?: number | null;
            type: components["schemas"]["PassengerType"];
            /** @description reduction or loyalty cards owned by the passenger
             *      */
            cards?: components["schemas"]["CardReference"][];
            gender?: components["schemas"]["Gender"];
            detail?: components["schemas"]["PersonDetail"];
            identificationCard?: components["schemas"]["IdentificationCard"];
            transportableDetails?: components["schemas"]["Transportable"];
            /** @description For the persons with reduced mobility (PRMs) its specific needs for support are expressed.
             *      */
            prmNeeds?: components["schemas"]["PRMNeedType"][];
            /** @description Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        PassengerConstraints: {
            /**
             * Format: int32
             * @description number of passengers with this constraint
             *
             */
            number?: number | null;
            /** Format: int32 */
            upperAgeLimit?: number | null;
            /** Format: int32 */
            lowerAgeLimit?: number | null;
        };
        PassengerResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            passenger?: components["schemas"]["Passenger"];
        };
        /** @description Minimal specification of a passenger to request offers.
         *     Either the date of birth or the age at the time of travel needs to be set. We recommend to use date of birth as it is more stable than age.
         *      */
        PassengerSpecification: {
            /**
             * @description A stable reference to a passenger from other elements, or from caller system. When received in input of a request, it must be echoed back in the response.
             *
             * @example TK-id-12345
             */
            externalRef: string;
            /**
             * Format: date
             * @description Date of birth of the passenger. Only needed for passengers of type persons, family child, PRM
             *     and wheelchair.
             *
             */
            dateOfBirth?: string | null;
            /** Format: int32 */
            age?: number | null;
            /** @description reduction or loyalty cards owned by the passenger
             *      */
            cards?: components["schemas"]["CardReference"][];
            /** @description For the persons with reduced mobility (PRMs) its specific needs for support are expressed.
             *      */
            prmNeeds?: components["schemas"]["PRMNeedType"][];
            detail?: components["schemas"]["PersonDetail"];
            type: components["schemas"]["PassengerType"];
            gender?: components["schemas"]["Gender"];
        };
        /**
         * @description Passenger type according to UIC passenger, i.e. passenger type list.
         *     Values from the [Passenger Type Code List](https://osdm.io/spec/catalog-of-code-lists/#PassengerType)
         *     Listed values here are examples.
         *     Proposed default PERSON
         *
         * @default PERSON
         */
        PassengerType: string;
        /** @description Method of payment used by the customer to the distributor. On input of voucher the remaining sum attribute is not present.
         *      */
        PaymentMethod: {
            type: components["schemas"]["PaymentType"];
            voucherInformation?: components["schemas"]["VoucherInformation"];
            remainingVoucherAmount?: components["schemas"]["Price"];
            transactionId?: string | null;
        };
        PaymentType: string;
        /** @description Personal information potentially needed at booking step. To support privacy by design,
         *     it is not permitted to send personal information not required to create a valid booking.
         *      */
        PersonDetail: {
            /**
             * @deprecated
             * @description ISO-639-1 language code
             *
             */
            preferredLanguage?: string | null;
            /** @description A human-readable description of the person.
             *      */
            summary?: string | null;
            firstName: string;
            /**
             * @description full last names of the person
             * @example Diaz Lopez
             */
            lastName: string;
            /**
             * @description first family name in case of multiple family names. The element lastName includes all family names.
             * @example Diaz
             */
            firstFamilyName?: string;
            /**
             * @description second family name in case of multiple family names. The element lastName includes all family names.
             * @example Lopez
             */
            secondFamilyName?: string;
            /** @deprecated */
            email?: string | null;
            /**
             * @deprecated
             * @description Preferably a mobile phone number, to be contacted in case changes to the booking occur, e.g.,
             *     in case of interruptions.
             *
             */
            phoneNumber?: string | null;
            /**
             * @deprecated
             * @description Deprecated in favor of `postalAddress`
             *
             */
            address?: components["schemas"]["Address"];
            /** @description Address of the physical person for issuing an invoice or receipt
             *      */
            postalAddress?: components["schemas"]["PostalAddress"];
            contact?: components["schemas"]["ContactDetail"];
            /**
             * @description Tax identification of the physical person for issuing an invoice or receipt
             * @example CZ1234567890
             */
            taxId?: string | null;
        };
        PersonSearchRequest: {
            firstName?: string | null;
            lastName?: string | null;
            /** Format: date */
            dateOfBirth?: string | null;
            phoneNumber?: string | null;
            email?: string | null;
        };
        /** @description A geographic place of any type which may be specified as the origin or destination of a trip. Provided by OJP.
         *      */
        Place: {
            /** @description Attribute is used as discriminator for inheritance between data types. */
            objectType: string;
            /**
             * @description id  defining the place. The code is provided as URN, relative URNs are allowed with base path urn:uic:stn '0850000'
             *
             * @example urn:uic:stn:8500000
             */
            id: string;
            /** @description For a place with ids in different reference systems, the alternative ids can be returned.
             *     The reference system is encoded in the string. E.g.: 'urn:uic:std:80000', 'x_swe:stn:10000', 'ch:1:sloid:343434'
             *      */
            alternativeIds?: string[] | null;
            geoPosition?: components["schemas"]["GeoPosition"];
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        /** @description Describes the details of the reserved place(s).
         *      */
        PlaceAllocation: {
            accommodationType: components["schemas"]["AccommodationType"];
            accommodationSubType: components["schemas"]["AccommodationSubType"];
            /** @description Reserved places in a confirmed reservation.
             *     Multiple place packs are needed to combined person and bicycle reservations
             *      */
            reservedPlaces: components["schemas"]["ReservedPlace"][];
            tripLegCoverage: components["schemas"]["TripLegCoverage"];
        };
        /** @description Availability of places on vehicle.
         *      */
        PlaceAvailability: {
            reference?: components["schemas"]["PartReference"];
            vehicle: components["schemas"]["Vehicle"];
            /** @description suggested pre-selection of places
             *      */
            preSelections?: components["schemas"]["PlacePreSelection"][];
        };
        PlaceAvailabilityCollectionResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            availablePlaces?: components["schemas"]["AvailablePlace"][];
        };
        PlaceAvailabilityResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            vehicleAvailability?: components["schemas"]["PlaceAvailability"];
        };
        PlaceAvailabilitiesResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            vehicleAvailabilities?: components["schemas"]["PlaceAvailability"][];
        };
        /** @description More parameters for restricting the request. Provided by OJP.
         *      */
        PlaceParam: {
            type?: components["schemas"]["PlaceType"];
            usage?: components["schemas"]["PlaceUsage"];
            ptModes?: components["schemas"]["ModeFilter"];
            serviceBrandFilter?: components["schemas"]["ServiceBrandFilter"];
            carrierFilter?: components["schemas"]["CarrierFilter"];
            pointOfInterestFilter?: components["schemas"]["PointOfInterestFilter"];
            /**
             * Format: int32
             * @description Maximum number of results to be returned. The service is allowed to return fewer objects if reasonable
             *     or otherwise appropriate.
             *
             */
            numberOfResults?: number | null;
        };
        /** @description description of a place
         *      */
        PlacePosition: {
            /** @description place number as indicated at the place in the coach
             *      */
            number: string;
            status: components["schemas"]["AvailabilityStatus"];
            /** @description references to the reservations for which this place nca be selected. The reservation ids must be part of the list of reservation ids for which the consumer has requested the available places and the consumer must accept a list by setting singleSelectionMapsRequired to false
             *      */
            reservationRefs?: string[];
            placeProperties?: components["schemas"]["PlaceProperty"][];
        };
        PlacePreSelection: {
            /** @description id of the reservation in case the places have already been selected and the customer now wants to change the selection.
             *      */
            reservationId?: string;
            coach: string;
            place: string;
        };
        PlacePreferenceGroup: {
            /**
             * @description Values from the [Reservation Preference Group Code List](https://osdm.io/spec/catalog-of-code-lists/#ReservationPreferenceGroup)
             *
             * @example BERTH_LOCATION
             */
            preferenceGroup: string;
            /**
             * @description Place preferences in the group.
             *     Values from the [Place Property Code List](https://osdm.io/spec/catalog-of-code-lists/#PlaceProperty)
             *
             * @example WINDOW
             */
            preferences: string[];
        };
        /**
         * @description Values from the [Place Property Code List](https://osdm.io/spec/catalog-of-code-lists/#PlaceProperty)
         *
         * @example Power Connection
         */
        PlaceProperty: string;
        PlaceRef: {
            /** @description Attribute is used as discriminator for inheritance between data types. */
            objectType: string;
        };
        /** @description Initial input for the place information request. This input defines what is originally looked for.
         *     Provided by OJP.
         *      */
        PlaceRequest: {
            placeInput?: components["schemas"]["InitialPlaceInput"];
            restrictions?: components["schemas"]["PlaceParam"];
        };
        PlaceResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            places: components["schemas"]["Place"][];
        };
        /** @description Place selection options and selected options in an offer
         *     - reference place for adjacent reservation
         *     - selected optional place properties
         *     - selected places from a graphical place selection
         *      */
        PlaceSelection: {
            reservationId: string;
            referencePlace?: components["schemas"]["SelectedReferencePlace"];
            accommodations?: components["schemas"]["SelectedAccommodation"][];
            places?: components["schemas"]["SelectedPlace"][];
            tripLegCoverage: components["schemas"]["TripLegCoverage"];
        };
        /**
         * @description Provided by OJP.
         *
         * @enum {string}
         */
        PlaceType: "STOP" | "ADDRESS" | "POI" | "GEO_COORDINATE" | "TOPOGRAPHIC_PLACE";
        /**
         * @description Provided by OJP.
         *
         * @enum {string}
         */
        PlaceUsage: "ORIGIN" | "VIA" | "DESTINATION";
        /** @description A type of place to or through which passengers may wish to navigate as part of
         *     their journey and which is modelled in detail by journey planners. Provided by OJP.
         *      */
        PointOfInterest: {
            objectType: "PointOfInterest";
        } & (Omit<components["schemas"]["Place"], "objectType"> & {
            /**
             * @description Name or description of point of interest for use in passenger information.
             *
             * @example Park Rozenrust
             */
            name: string;
            /** @description id of the Point of Interest.
             *      */
            code: string;
            ref?: components["schemas"]["PointOfInterestRef"];
        });
        /** @description A categorization of points of interest in respect of the activities undertaken at them (defined by key-value-pairs). Provided by OJP.
         *      */
        PointOfInterestCategory: {
            /** @description Open Street Map tag structure (key-value)
             *      */
            osmTags?: components["schemas"]["OsmTag"][];
            /** @description Classification of the POI (when it is not from OSM). The codification of the
             *     classification Id may include de codification source (for example
             *     'IGN:[classificationCode]')
             *      */
            pointOfInterestClassifications?: string[] | null;
        };
        /** @description Filter POIs by category. Provided by OJP.
         *      */
        PointOfInterestFilter: {
            /**
             * @description Whether carriers are to be included or excluded from the filtering.
             *
             * @default true
             */
            exclude: boolean;
            /** @description These POI categories can be used to filter POIs. If more than one is given the filtering
             *     is by logical 'OR' (when Exclude=FALSE) and logical 'AND' (when Exclude=TRUE).
             *      */
            pointOfInterestCategory?: components["schemas"]["PointOfInterestCategory"][];
        };
        /** @description Reference to a Point of Interest. Provided by OJP.
         *      */
        PointOfInterestRef: {
            objectType: "PointOfInterestRef";
        } & (Omit<components["schemas"]["PlaceRef"], "objectType"> & {
            pointOfInterestRef: string;
        });
        Polygon: {
            edges: components["schemas"]["GeoPosition"][];
        };
        Price: {
            currency: components["schemas"]["Currency"];
            /**
             * Format: int32
             * @description amount in cents
             *
             */
            amount: number;
            /**
             * Format: int32
             * @description scale of the amount - the number of positions after the comma
             *
             * @default 2
             */
            scale: number;
            vats?: components["schemas"]["VAT"][];
        };
        /** @description Problem Details for HTTP APIs (RFC 9457) defines a 'problem detail' as a way
         *     to carry machine-readable details of errors in a HTTP response to avoid
         *     the need to define new error response formats for HTTP APIs.
         *     See: https://tools.ietf.org/html/rfc9457
         *      */
        Problem: {
            /** @description optional in version 3.1, will be made mandatory in upcoming releases
             *      */
            code?: string | null;
            /**
             * Format: uri
             * @description An absolute URI that identifies the problem type. When dereferenced,
             *     it SHOULD provide human-readable documentation for the problem type
             *     (e.g., using HTML).
             *
             * @default about:blank
             * @example https://example.com/probs/passenger-too-young
             */
            type: string;
            /**
             * @description A short, summary of the problem type. Written in English and readable
             *     for engineers (usually not suited for non technical stakeholders and
             *     not localized);
             *
             * @example Service Unavailable
             */
            title?: string | null;
            /**
             * Format: int32
             * @description The HTTP status code generated by the origin server for this occurrence
             *     of the problem.
             *
             * @example 503
             */
            status?: number | null;
            /**
             * @description A human readable explanation specific to this occurrence
             *     of the problem.
             *
             * @example Connection to database timed out
             */
            detail?: string | null;
            /**
             * Format: uri
             * @description An absolute URI that identifies the specific occurrence of the problem.
             *
             */
            instance?: string | null;
            pointers?: components["schemas"]["ProblemPointer"][];
        };
        /** @description Problem Details for HTTP APIs (RFC 9457) defines a 'problem detail' as a way
         *     to carry machine-readable details of errors in a HTTP response to avoid
         *     the need to define new error response formats for HTTP APIs.
         *     See: https://tools.ietf.org/html/rfc9457
         *      */
        ProblemPointer: {
            /** @description optional in version 3.1, will be made mandatory in upcoming releases
             *      */
            code?: string | null;
            /**
             * Format: uri
             * @description An absolute URI that identifies the problem type. When dereferenced,
             *     it SHOULD provide human-readable documentation for the problem type
             *     (e.g., using HTML).
             *
             * @default about:blank
             * @example https://example.com/probs/passenger-too-young
             */
            type: string;
            /**
             * @description A short, summary of the problem type. Written in English and readable
             *     for engineers (usually not suited for non technical stakeholders and
             *     not localized);
             *
             * @example Service Unavailable
             */
            title?: string | null;
            /**
             * Format: int32
             * @description The HTTP status code generated by the origin server for this occurrence
             *     of the problem.
             *
             * @example 503
             */
            status?: number | null;
            /**
             * @description A human readable explanation specific to this occurrence
             *     of the problem.
             *
             * @example Connection to database timed out
             */
            detail?: string | null;
            /**
             * Format: uri
             * @description An absolute URI that identifies the specific occurrence of the problem.
             *
             */
            instance?: string | null;
            /**
             * @description A pointer to the attribute in the request for the problem.
             *
             * @example #/offers[1]/placeSelections[1]/reservationId
             */
            requestPointer?: string | null;
            /**
             * @description A pointer to the attribute in the response for the problem.
             *
             * @example #/booking/bookedOffers[4]/reservations[1]/id
             */
            responsePointer?: string | null;
            /**
             * @description Identifier to the origin server for this occurrence of the problem.
             *
             * @example IMS1
             */
            originator?: string | null;
        };
        /** @description Structured description of the product, its name, comfort and sales / after-sales conditions
         *      */
        Product: {
            /** @description id of the product
             *      */
            id: string;
            /** @description A human-readable description of the product.
             *      */
            summary?: string | null;
            type?: components["schemas"]["ProductType"];
            /**
             * @description The product code expressed in the provider system (could be a
             *     mapping from an even lower-level provider).
             *
             * @example PT00AD
             */
            code: string;
            /** @description Textual description of the product.
             *      */
            description?: string | null;
            owner: components["schemas"]["CompanyRef"];
            /** @description Structured description of the sales or after-sales conditions.
             *      */
            conditions?: components["schemas"]["Condition"][];
            flexibility: components["schemas"]["Flexibility"];
            serviceClass?: components["schemas"]["ServiceClass"];
            travelClass?: components["schemas"]["TravelClass"];
            fulfillmentOptions?: components["schemas"]["FulfillmentOption"][];
            /** @default false */
            isTrainBound: boolean | null;
            /** @default false */
            isReturnProduct: boolean | null;
            serviceConstraintText?: string | null;
            carrierConstraintText?: string | null;
            descriptiveTexts?: components["schemas"]["TextElement"][];
            /** @description Mapping to Tariff 42 of IRS-90918-3 (Hermes/Hosa). Helps the H2O converter in mapping
             *     offers to a requested tariff. See legacyReservationParameter.tariff in OSDM offline.
             *      */
            tariff?: string | null;
            combinationTags?: components["schemas"]["CombinationTag"][];
            /** @description product tags associated with the product that can be used to search for offers. This can be omitted outside of the product master data service */
            productTags?: (string | null)[];
            /** @description Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        /** @description Known values:
         *     - SPLIT_RESERVATION
         *       Indicate for the provider that the distributor is prepared to get reservations including a split inside the reservation
         *       Without this indication the provider is not allowed to use the SplitSection Object inside a reservation.
         *       The implementation of SPLIT_RESERVATION is not recommended. To provide reservations that do not cover a full leg
         *       multiple reservations as offerParts should be created.
         *      */
        ProductTag: string;
        /** @description General product types harmonized across fare providers. (More to be added, use null for types not listed yet.)
         *     Values from the [Product Type Code List](https://osdm.io/spec/catalog-of-code-lists/#ProductTypes)
         *     Listed values here are examples.
         *      */
        ProductType: string;
        /** @description Product category based on NeTEx/SIRI. A product category is a classification for vehicle journeys
         *     to express some common properties of journeys for marketing and fare products. Provided by OJP.
         *      */
        ProductCategory: {
            /**
             * @description Full name of this product category, e.g. 'TGV Lyria' in Switzerland and France.
             *     UIC: Long name of Service Brand
             *
             * @example TGV Lyria
             */
            name: string;
            /**
             * @description Short name or acronym of the product category, likely to be published, e.g. 'TGV'
             *     UIC: Abbreviation of Service Brand
             *
             * @example TGV
             */
            shortName: string;
            productCategoryRef: components["schemas"]["ProductCategoryRef"];
        };
        /**
         * @description Reference to a product category. Product categories should be defined once and used
         *     uniformly in all channels (e.g. NeTEx, SIRI, OJP). Provided by OJP.
         *
         * @example urn:uic:sbc:76
         */
        ProductCategoryRef: string | null;
        ProductCollectionResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            /** @description The list of all products available to the caller.
             *      */
            products?: components["schemas"]["Product"][];
        };
        /** @description In offer mode, in almost all cases exactly one product is referenced. Only on some French
         *     trips consisting of a TGV and a TER two products need to be used.
         *     In fare mode, no product exists as first needs to created from the different fares.
         *      */
        ProductLegAssociation: {
            productId: string;
            /** @description indices of the legs in the trip given by the provider of the offer
             *      */
            legIds?: string[] | null;
        };
        ProductResponse: {
            warnings?: components["schemas"]["WarningCollection"];
            product?: components["schemas"]["Product"];
        };
        /** @description Summary of the booking's underlining products.
         *      */
        ProductSummary: {
            id: string;
            description: string;
            code: string;
        };
        /** @description The promotion code is a token that reduces the price at POST booking time OR
         *     Token that reduces the price at POST trip-offer-collection time OR
         *     Token to receive offers that are not available without it.
         *      */
        PromotionCode: {
            /**
             * @description The code issued by the issuer
             *
             * @example SPRING_DISCOUNT
             */
            code: string;
            /** @description The party that issues the promotion code, in case of a railway it's its RICS code
             *      */
            issuer?: string | null;
        };
        /** @description purchaser information
         *      */
        Purchaser: {
            /** @description A stable reference to a purchaser from other elements, or from caller system. When received in input of a request, it must be echoed back in the response.
             *      */
            externalRef?: string | null;
            detail?: components["schemas"]["PersonDetail"];
            companyDetails?: components["schemas"]["CompanyDetail"];
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        PurchaserResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            purchaser?: components["schemas"]["Purchaser"];
        };
        PurchaserSearchRequest: {
            companyName?: string | null;
            companyRef?: components["schemas"]["CompanyRef"];
            firstName?: string | null;
            lastName?: string | null;
            /** Format: date */
            dateOfBirth?: string | null;
            phoneNumber?: string | null;
            email?: string | null;
        };
        /** @description Minimal specification of a purchaser to request booking of an offer.
         *      */
        PurchaserSpecification: {
            /** @description A stable reference to a purchaser from other elements, or from caller system. When received in input of a request, it must be echoed back in the response.
             *      */
            externalRef?: string | null;
            detail: components["schemas"]["PersonDetail"];
            companyDetails?: components["schemas"]["CompanyDetail"];
        };
        /** @description Generic entity to model a quantity.
         *      */
        Quantity: {
            /** Format: float */
            value: number;
            /** @example kg */
            unit: string;
        };
        ReductionCardAccount: {
            objectType: "ReductionCardAccount";
        } & (Omit<components["schemas"]["AbstractTravelAccount"], "objectType"> & {
            type: components["schemas"]["ReductionCardType"];
        });
        ReductionCardCollectionResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            reductionCardTypes?: components["schemas"]["ReductionCardType"][];
        };
        ReductionCardType: {
            code: string;
            issuer: components["schemas"]["CompanyRef"];
            name: components["schemas"]["Text"];
            /**
             * @description the card id must be delivered in online sales
             *
             * @default false
             */
            cardIdRequired: boolean | null;
            /** @description This card includes the listed cards
             *      */
            includedCardTypes?: components["schemas"]["CardTypeReference"][];
            /** @description list of service classes where this card applies
             *      */
            serviceClassTypes?: components["schemas"]["ServiceClassType"][];
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        RefundOffer: {
            /** @description id of the refund offer
             *      */
            id: string;
            /**
             * @description A human-readable description of the refund offer.
             *
             * @example Refund Offer for Paris-Barcelona Andre Dupont 2022-07-23
             */
            summary?: string | null;
            /** Format: date-time */
            createdOn: string;
            /** Format: date-time */
            validFrom: string;
            /**
             * Format: date-time
             * @description time until the offer can be used
             *
             */
            validUntil: string;
            /** Format: date-time */
            confirmedOn?: string | null;
            status: components["schemas"]["RefundStatus"];
            reimbursementStatus?: components["schemas"]["ReimbursementStatus"];
            /** Format: date-time */
            reimbursementDateTime?: string | null;
            appliedOverruleCode?: components["schemas"]["OverruleCode"];
            /** @description fulfillments to be refunded or replaced */
            fulfillments: components["schemas"]["Fulfillment"][];
            /** @description new fulfillments issued with this offer (only available after confirmation) */
            issuedFulfillments?: components["schemas"]["Fulfillment"][];
            issuedVouchers?: components["schemas"]["VoucherInformation"][];
            /** @description Amount kept by the carrier and/or distributor
             *      */
            refundFee: components["schemas"]["Price"];
            /** @description Accounting information for the refund fee
             *      */
            accountingRef?: components["schemas"]["AccountingRef"];
            /** @description Amount refunded to the purchaser
             *      */
            refundableAmount: components["schemas"]["Price"];
            /** @description breakdown of the refund offer
             *      */
            refundOfferBreakdown?: components["schemas"]["RefundOfferBreakdownItem"][];
            reimbursementMethod?: components["schemas"]["ReimbursementMethod"];
            /** @description Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        RefundOfferBreakdownItem: {
            /** @description Amount kept by the carrier and/or the distributor */
            refundFee: components["schemas"]["Price"];
            /** @description Amount to be returned to the purchaser */
            refundableAmount: components["schemas"]["Price"];
            bookingParts: components["schemas"]["BookingPartReference"][];
        };
        RefundOfferCollectionResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            refundOffers?: components["schemas"]["RefundOffer"][];
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        /** @description Changes the refund offer to status CONFIRMED. De-confirmation by setting PROPOSED status is not supported by API.
         *      */
        RefundOfferPatchRequest: {
            status: components["schemas"]["RefundStatus"];
        };
        /** @description Request for a refund offer.
         *     Fulfillments can be provided in case the booking contains multiple individual fulfillments.
         *      */
        RefundOfferRequest: {
            /** @description ids of the fulfillments to refund
             *      */
            fulfillmentIds: string[];
            /** @description To do a partial refund repeat the fulfillmentIds affected and point out what to refund
             *      */
            refundSpecifications?: components["schemas"]["RefundSpecification"][];
            overruleCode?: components["schemas"]["OverruleCode"];
            /**
             * Format: date-time
             * @description Indicates for passes the date taken as reference to compute possible partial refund. It is also the date taken
             *     as reference to invalidate the pass partially refunded.
             *
             */
            refundDate?: string | null;
        };
        RefundOfferResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            refundOffer?: components["schemas"]["RefundOffer"];
        };
        RefundSpecification: {
            /** @description id of the fulfillment where some part(s) should be removed
             *      */
            fulfillmentId: string;
            /** @description ids of booking parts to be removed from the fulfillment */
            bookingPartIds?: string[];
            /** @description ids of passengers to be removed from the fulfillment */
            passengerIds?: string[];
        };
        /** @enum {string} */
        RefundStatus: "PROPOSED" | "CONFIRMED";
        /** @enum {string} */
        RefundType: "YES" | "NO" | "WITH_CONDITION";
        /** @description Regional constraint of the fare- offline bulk data use the id of connection points whereas  in an online environment the connection point is included
         *      */
        RegionalConstraint: {
            entryConnectionPoint?: components["schemas"]["FareConnectionPoint"];
            exitConnectionPoint?: components["schemas"]["FareConnectionPoint"];
            regionalValidities: components["schemas"]["RegionalValidity"][];
            /**
             * Format: int32
             * @description Distance in km for statistics
             *
             */
            distance?: number | null;
        };
        /** @description One of the elements Zone, ViaStation, TrainLink, Line, or Polygon defining the regional validity
         *      */
        RegionalValidity: {
            /**
             * Format: int32
             * @description order number of the list item
             *
             */
            seqNb?: number | null;
            zone?: components["schemas"]["Zone"];
            route?: components["schemas"]["Route"];
            trainLink?: components["schemas"]["TrainLink"];
            line?: components["schemas"]["Line"];
            polygon?: components["schemas"]["Polygon"];
            serviceConstraint?: components["schemas"]["ServiceConstraint"];
        };
        RegionalValiditySummary: {
            description: string;
            shortDescription: string | null;
        };
        /**
         * @description General conditions applied to cover legal regulations within the area of validity. Allocators must
         *     reflect these terms and conditions in the conditions of combined offers and indicate them to the customer
         *     where required. Which indications are mandatory to be shown to the customer is defined in the SCICs.
         *
         *     Valid Values:
         *     - CIV: terms and conditions according to COTIV regulation
         *     - MD: terms and conditions according to SMPS regulation
         *     - EU_PRR: terms and conditions according to EU-PRR regulation
         *
         * @enum {string}
         */
        RegulatoryCondition: "CIV" | "MD" | "EU_PRR";
        /** @description Customers who have bought a ticket which allows reimbursement and which have not traveled or traveled partially only can claim to be reimbursed. The customer must prove that he has not or only partially used the ticket. A partial use might be a only a part of the trip was traveled or only some of the travelers were traveling or a combination of both.
         *      */
        Reimbursement: {
            id: string;
            request: components["schemas"]["ReimbursementRequest"];
            status: components["schemas"]["BackOfficeStatus"];
            missingInformation?: string[] | null;
            decision?: components["schemas"]["ReimbursementDecision"];
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        /** @description Decision whether or not the reimbursement is granted. Contains information on the amount reimbursed.
         *      */
        ReimbursementDecision: {
            amount?: components["schemas"]["Price"];
            voucher?: components["schemas"]["FulfillmentDocument"];
            explanation?: components["schemas"]["SupportingDocument"];
            shortExplanation?: string | null;
        };
        /** @description reimbursement methods to inform on restrictions of the payment method
         *      */
        ReimbursementMethod: {
            /** @description payment method to be used for the reimbursement
             *      */
            paymentMethod?: string;
        };
        ReimbursementPatchRequest: {
            additionalDocuments: components["schemas"]["SupportingDocument"][];
            updatedStatus: components["schemas"]["BackOfficeStatus"];
        };
        /** @description Reason why the booking should be reimbursed.
         *      */
        ReimbursementReason: string;
        /** @description The reimbursement process is used to support refunds which are not covered by the online refund/exchange processes, e.g.: Partial refund of a trip (Trip was Hamburg - Munich, but only Hamburg - Kassel was used), Refund outside of rules due to good will. This is a manual back office process within the provider's organization which is triggered by this request. State changes can be signaled by web hook events.
         *      */
        ReimbursementRequest: {
            reimbursementReason: components["schemas"]["ReimbursementReason"];
            /** Format: date-time */
            reimbursementDate?: string | null;
            reimbursedPassengerIds: string[];
            tripSections?: components["schemas"]["TripSection"][];
            fulfillmentIds: string[];
            supportingDocuments?: components["schemas"]["SupportingDocument"][];
        };
        /** @description Response to a reimbursement request, containing a state and a decision.
         *      */
        ReimbursementResponse: {
            reimbursement: components["schemas"]["Reimbursement"];
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
        };
        /**
         * @default IMMEDIATE
         * @enum {string}
         */
        ReimbursementStatus: "IMMEDIATE" | "DELAYED";
        ReleaseOffer: {
            /** @description id of the release offer
             *      */
            id: string;
            /** @description A human-readable description of the refund offer.
             *      */
            summary?: string | null;
            /** Format: date-time */
            createdOn: string;
            /** Format: date-time */
            validFrom: string;
            /**
             * Format: date-time
             * @description time until the offer can be used
             *
             */
            validUntil: string;
            /** Format: date-time */
            confirmedOn?: string | null;
            status: components["schemas"]["ReleaseStatus"];
            fulfillments: components["schemas"]["Fulfillment"][];
            appliedOverruleCode?: components["schemas"]["OverruleCode"];
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        ReleaseOfferCollectionResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            releaseOffers?: components["schemas"]["ReleaseOffer"][];
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        ReleaseOfferPatchRequest: {
            status: components["schemas"]["ReleaseStatus"];
        };
        ReleaseOfferRequest: {
            fulfillmentIds?: components["schemas"]["FulfillmentId"][];
            /** @description To do a partial release repeat the fulfillmentIds affected and point out what to release
             *      */
            releaseSpecifications?: components["schemas"]["RefundSpecification"][];
            overruleCode?: components["schemas"]["OverruleCode"];
        };
        ReleaseOfferResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            releaseOffer?: components["schemas"]["ReleaseOffer"];
        };
        /** @enum {string} */
        ReleaseStatus: "PROPOSED" | "CONFIRMED";
        /** @description Remark concerning the place (e.g. to be used in a tool tip).
         *     Code list according to UIC90918-1
         *     Known Values:
         *     - MIGHT_HAVE_TABLE: place might have a table
         *     - MIGHT_NOT_HAVE_TABLE: table at the place might be missing
         *     - MIGHT_HAVE_DIFFERENT_DIRECTION: place might have a different direction
         *     - MIGHT_HAVE_TABLE_AND_DIFFERENT_DIRECTION: place might have a table and a different direction
         *     - MIGHT_NOT_HAVE_TABLE_AND_MIGHT_HAVE_DIFFERENT_DIRECTION: table at the place might be missing and place might have a different direction
         *     - MIGHT_BE_IN_COMPARTMENT: place might be in compartment
         *     - MIGHT_BE_IN_OPEN_SPACE: place might be in open space
         *      */
        RemarkType: string;
        /** @description Boolean-expression indicating the data that must be set in the data model in order to proceed to next step of the process.
         *
         *     The syntax and semantics of the expression is described in detail in the OSDM documentation.
         *      */
        RequestedInformation: string | null;
        /** @description Reservation includes the reference to the in the initial offer.
         *     The offer needs to be updated with the selected places before the confirmation
         *     which creates the reservation details including the reserved places.
         *      */
        Reservation: {
            objectType: "Reservation";
        } & (Omit<components["schemas"]["AbstractBookingPart"], "objectType"> & {
            placeSelection?: components["schemas"]["PlaceSelection"];
            placeAllocation?: components["schemas"]["PlaceAllocation"];
            feeRefs?: components["schemas"]["BookingPartReference"][];
            ancillaryRefs?: components["schemas"]["BookingPartReference"][];
            /** @default false */
            graphicalReservationSupported: boolean | null;
        });
        ReservationGroup: {
            id: string;
            name: string;
            reservationRefs: components["schemas"]["OfferPartReference"][];
        };
        /** @description Reservation includes the reference to the in the initial offer.
         *     The offer needs to be updated with the selected places before the confirmation
         *     which creates the reservation details including the reserved places.
         *      */
        ReservationOfferPart: {
            objectType: "ReservationOfferPart";
        } & (Omit<components["schemas"]["AbstractOfferPart"], "objectType"> & {
            ancillaries?: components["schemas"]["AncillaryRelation"][];
            availablePlaces?: components["schemas"]["AvailablePlace"][];
            availablePlacePreferences?: components["schemas"]["AvailablePlacePreferences"][];
            feeRefs?: components["schemas"]["OfferPartReference"][];
            /** Format: int32 */
            numberOfPrivateCompartments?: number | null;
        });
        ReservationRelation: {
            /** Format: int32 */
            minGroupItemsToBeBooked: number;
            /** Format: int32 */
            maxGroupItemsToBeBooked?: number | null;
            reservationGroup: components["schemas"]["ReservationGroup"];
        };
        ReservationSelection: {
            reservationId: string;
        };
        /** @description In distributor mode placeProperties are mandatory to be returned.
         *      */
        ReservedPlace: {
            id: string;
            /** @description Id of the passenger
             *      */
            passengerIds: string[];
            /** @description vehicle number (e.g. train number)
             *      */
            vehicleNumber: string;
            coachNumber: string;
            /** @description description of the places (e.g. 11-35,51)
             *      */
            placeDescription?: string | null;
            /** @description list of individual place numbers
             *      */
            placeNumbers?: string[] | null;
            /** @description place properties to be indicated to the customer
             *      */
            placeProperties?: components["schemas"]["PlaceProperty"][];
            /** @description Indication of the covered part of a leg in case the reserved
             *     place does not cover the whole leg. This element is allowed
             *     on in case the offer was requested using the SPLIT_RESERVATION product tag
             *     an implementation is not recommended.
             *      */
            splitSection?: components["schemas"]["Section"];
        };
        Resource: {
            title: string;
            href: string;
        };
        /** @enum {string} */
        ResourceType: "FARE" | "RESERVATION";
        /** @description a return trip with the same carrier must be sold in combination
         *      */
        ReturnConstraint: {
            /**
             * Format: int32
             * @description number of days after departure or start of validity of the last return
             *
             */
            latestReturn: number;
            /**
             * Format: int32
             * @description number of days after departure or start of validity of the earliest return
             *
             */
            earliestReturn: number;
            /** @description weekdays (ISO day of the week, 1 = Monday) between travel and return where travel is not allowed
             *      */
            excludedWeekdays?: number[] | null;
        };
        /** @description This property can be used in case a return trip is being requested.
         *     This will allow to benefit from return-specific fares or product
         *      */
        ReturnSearchParameters: {
            /** @description Needs to be provided when creating the collection of outward travels so that the
             *     provider knows when a return travel can be expected and propose appropriate
             *     product and fares.
             *      */
            inwardReturnDate?: string | null;
            /** @description Needs to be provided when creating the collection of inward travels so that the provider
             *     can relate the inward travels to the outward travels context.
             *      */
            outwardOfferIds?: string[] | null;
            /** @description Needs to be provided when creating the collection of inward travels so that the provider
             *     knows what the outward offer is and and propose compatible offers only if desired or mandatory.
             *      */
            outwardOfferTag?: string | null;
        };
        /** @description Route description including the first and last real stopPoint
         *      */
        Route: {
            routeItem?: components["schemas"]["RouteItem"];
            /** @description list of route items referenced within the list
             *      */
            routeItemList?: components["schemas"]["RouteItem"][];
        };
        /** @description Items to compose routes (Note - replaced viaStation, content compliant with viaStation in IRS 90918-4 and 90918-9)
         *      */
        RouteItem: {
            /** @description list of alternative route parts to be used on this travel path referenced by the index in the provided list of route items
             *      */
            alternativeRouteItemIndices?: number[] | null;
            carrierConstraint?: components["schemas"]["CarrierConstraint"];
            /** @description sequence of route items along the travel path referenced by the index in the provided list of route items
             *      */
            routeItemIndices?: number[] | null;
            serviceConstraint?: components["schemas"]["ServiceConstraint"];
            station?: components["schemas"]["StopPlace"];
            fareReferenceStation?: components["schemas"]["FareReferenceStation"];
        };
        /** @description Allows to indicate the sub-part of the trip. LegIds are only relevant if
         *     a trip can be referenced. When absent, the totality of the trip is priced.
         *      */
        Section: {
            startPlace?: components["schemas"]["PlaceRef"];
            startLegId?: string | null;
            endPlace?: components["schemas"]["PlaceRef"];
            endLegId?: string | null;
            /** @description reference to a trip in case multiple trips are provided */
            externalTripRef?: string | null;
        };
        /** @enum {string} */
        SecurityElementFormat: "PNG" | "GIF" | "SVG" | "BINARY" | "TEXT";
        /** @enum {string} */
        SecurityElementType: "VISUAL_ELEMENT" | "BAR_CODE";
        /** @description Defines type and format of the security feature.
         *      */
        SecurityFeatureType: {
            type?: components["schemas"]["SecurityElementType"];
            format?: components["schemas"]["SecurityElementFormat"];
            symbology?: components["schemas"]["Symbology"];
        };
        /** @description Place selection of places for reservation linked to passengers.
         *      */
        SelectedAccommodation: {
            /** @description Id of the passenger
             *      */
            passengerRefs: string[];
            accommodationType: components["schemas"]["AccommodationType"];
            accommodationSubType: components["schemas"]["AccommodationSubType"];
            /** @description Properties of places as defined in 90810-10.
             *     selection from the optional place properties provided in the offer
             *      */
            placeProperties?: string[] | null;
        };
        /** @description selected place in case of graphical booking
         *      */
        SelectedPlace: {
            coachNumber: string;
            placeNumber: string;
            /** @description Id of the passenger
             *      */
            passengerRef: string;
        };
        /** @description reference place for an adjacent reservation
         *      */
        SelectedReferencePlace: {
            coachNumber: string;
            placeNumber: string;
        };
        /**
         * @description Service brand codes. For public transport, a code list can be found in OSDM's code list. E.g., '163' denotes TGV Lyria and '175' denotes Glacier Express.
         *
         * @example 163, 175
         */
        ServiceBrandCode: string;
        /** @description Filter for in/exclusion of service brands. Provided by OJP.
         *      */
        ServiceBrandFilter: {
            /**
             * @description Whether service brand in list are to include or exclude from search.
             *
             * @default true
             */
            exclude: boolean;
            /** @description Reference to service brand codes
             *      */
            serviceBrands?: components["schemas"]["ServiceBrandCode"][];
        };
        /** @description Class of service.
         *      */
        ServiceClass: {
            type: components["schemas"]["ServiceClassType"];
            /** @description The name the carrier itself uses to designate this specific service class.
             *      */
            name: string;
        };
        /** @description Type of quality level, finer grained than the comfort class.
         *     Values from the [Service Class Code List](https://osdm.io/spec/catalog-of-code-lists/#ServiceClass)
         *     Listed values here are examples.
         *      */
        ServiceClassType: string;
        /** @description Either excluded or included service brands can be set.
         *      */
        ServiceConstraint: {
            restrictedToServiceBrands?: components["schemas"]["ServiceBrandCode"][];
            excludedServiceBrands?: components["schemas"]["ServiceBrandCode"][];
            description?: components["schemas"]["Text"];
        };
        /** @description enumeration of service degradations
         *      */
        ServiceDegradation: string;
        /** @description Parameters which describe the current status of a dated vehicle journey.
         *     Provided by OJP.
         *      */
        ServiceStatus: {
            /**
             * @description Whether this trip is an additional one that has not been planned.
             *
             * @default false
             */
            unplanned: boolean | null;
            /**
             * @description Whether this trip is cancelled and will not be run.
             *
             * @default false
             */
            cancelled: boolean | null;
            /**
             * @description Whether this trip deviates from the planned service pattern.
             *
             * @default false
             */
            deviation: boolean | null;
            /** @description Passenger load status on vehicle. If omitted, not known.
             *     Equivalent to siri:OccupancyEnumeration which describes three values:
             *     'full', 'seatingAvailable' and 'standingAvailable'.
             *      */
            occupancy?: string | null;
        };
        /** @description The time needs to be in Offset Time Format, i.e.  2023-12-03T10:15:30+01:00 as it is important the time zones are important  to show in the timetable.
         *
         *     Do not use the Coordinated Universal Time (UTC) format, i.e. 2023-12-03T10:15:30Z.
         *      */
        ServiceTime: {
            /** Format: date-time */
            timetabledTime: string;
            /** Format: date-time */
            estimatedTime?: string | null;
            /** Format: date-time */
            observedTime?: string | null;
        };
        /** @description Type of the exchange of control data for security in system implementations.
         *     Values from the [Control Data Exchange Type Code List](https://osdm.io/spec/catalog-of-code-lists/#ControlDataExchangeType)
         *     Listed values here are examples.
         *      */
        SiSType: string;
        /** @description Reference to situation message. Message details might be found in response
         *     context or through other communication channels. Provided by OJP.
         *      */
        SituationFullRef: string | null;
        /** @description indication of special coach
         *      */
        SpecialCoachType: string;
        StationSet: {
            stations: components["schemas"]["StopPlaceRef"][];
        };
        /** @enum {string} */
        StopBehavior: "ORIGIN_DESTINATION_ONLY" | "REAL_BOARDING_ALIGHTING";
        /** @description Status properties for the vehicle call at this stop. Provided by OJP.
         *      */
        StopCallStatus: {
            /**
             * Format: int32
             * @description Sequence number of this stop in the service pattern of the journey.
             *
             */
            order?: number | null;
            /**
             * @description The vehicle journey calls at this stop only on demand.
             *
             * @default false
             */
            requestStop: boolean | null;
            /**
             * @description This stop has not been planned by the planning department.
             *
             * @default false
             */
            unplannedStop: boolean | null;
            /**
             * @description The vehicle will not call at this stop despite earlier planning.
             *
             * @default false
             */
            notServicedStop: boolean | null;
            /**
             * @description Boarding will not be allowed at this stop of this journey.
             *
             * @default false
             */
            noBoardingAtStop: boolean | null;
            /**
             * @description Alighting will not be allowed at this stop of this journey.
             *
             * @default false
             */
            noAlightingAtStop: boolean | null;
        };
        /** @description A place extended by accessibility limitation properties and some attributes of the associated equipment,
         *     comprising one or more places where vehicles may stop and where passengers may board or leave vehicles
         *     or prepare their trip, and which will usually have one or more wellknown names. Provided by OJP.
         *      */
        StopPlace: {
            objectType: "StopPlace";
        } & (Omit<components["schemas"]["Place"], "objectType"> & {
            ref?: components["schemas"]["StopPlaceRef"];
            /**
             * @description Name of this stop place for use in passenger information.
             *
             * @example Zürich HB
             */
            name: string;
        });
        /** @description Reference to a Stop Place using URNs to define code.
         *     For UIC see UIC MERITS/TAP-TSI station codes. Provided by OJP.
         *      */
        StopPlaceRef: {
            objectType: "StopPlaceRef";
        } & (Omit<components["schemas"]["PlaceRef"], "objectType"> & {
            /** @example urn:uic:stn:8503000 */
            stopPlaceRef: string;
        });
        /** @description The supporting document helps to supporting the claim.  Either downloadLink + downloadExpiry or content must be provided.
         *      */
        SupportingDocument: {
            /**
             * @description title of the document
             *
             * @example delay confirmation written by staff on board
             */
            title: string;
            downloadLink?: string | null;
            /** Format: date-time */
            downloadExpiry: string;
            /**
             * Format: byte
             * @description base64 encoded binary of the actual document. The length restriction of 4 MBytes applies to the encoded
             *     string, so the raw document cannot exceed 3 MBytes in size.
             *
             */
            content?: string | null;
            format: components["schemas"]["DocumentFormat"];
        };
        /**
         * @description Symbology to use when rendering the binary data.
         *
         * @enum {string}
         */
        Symbology: "AZTEC" | "Code128A" | "Code128B" | "Code128C" | "QR" | "TEXT";
        /** @description Directly included text in case of online services. Text must be encoded in UTF-8 format.
         *      */
        Text: {
            id: string;
            translations?: components["schemas"]["Translation"][];
            text: string;
            shortText?: string | null;
        };
        /** @description Additional texts which should be displayed to the customer to further describe the product being offered.
         *      */
        TextElement: {
            /** @description Full version of the text for display when sufficient space is available.
             *      */
            description: string;
            /** @description Brief version of the text for display in space restricted environments, e.g. mobile phone. No longer than 64 characters.
             *      */
            shortDescription: string;
            textElementType: components["schemas"]["TextElementType"];
        };
        /**
         * @description Type of descriptive text.
         *     Valid Values:
         *     - INFORMATION: pure informational text (product/fulfillment).
         *     - MANDATORY: must be displayed to the customer prior to purchase (product).
         *     - MANDATORY_WITH_CONFIRMATION: must be confirmed, e.g. by checking a checkbox, prior to purchase (product).
         *     - TICKET_VALIDITY: any text on the ticket regarding it's validity (other than information which can be retrieved from the booking)
         *
         * @enum {string}
         */
        TextElementType: "INFORMATION" | "MANDATORY" | "MANDATORY_WITH_CONFIRMATION" | "TICKET_VALIDITY";
        /** @description Known Values:
         *     - RESPLUS: Through ticket tag according to Swedish Regulation.
         *      */
        ThroughTicketTag: string;
        /** @enum {string} */
        TimeUnit: "DAYS" | "HOURS" | "MINUTES";
        /** @description A leg which is bound to a timetabled schedule. Corresponds to a ride. Provided by OJP.
         *      */
        TimedLeg: {
            start: components["schemas"]["Board"];
            intermediates?: components["schemas"]["Intermediate"][];
            end: components["schemas"]["Alight"];
            service: components["schemas"]["DatedJourney"];
            operatingDays?: components["schemas"]["OperatingDays"];
            /** @description Textual description of the operation days, e.g. 'Monday to Friday' or 'not on holidays'.
             *      */
            operatingDaysDescription?: string | null;
            /** Format: duration */
            duration?: string | null;
            co2Emission?: components["schemas"]["Quantity"];
            attributes?: components["schemas"]["LegAttribute"][];
        };
        /** @description A minimal timed leg specification.
         *      */
        TimedLegSpecification: {
            start: components["schemas"]["BoardSpecification"];
            intermediates?: components["schemas"]["IntermediateSpecification"][];
            end: components["schemas"]["AlightSpecification"];
            service: components["schemas"]["DatedJourney"];
        };
        Trailer: {
            /**
             * Format: int32
             * @description weight in kg
             *
             */
            weight: number;
            /**
             * Format: int32
             * @description length in cm
             *
             */
            length: number;
            /**
             * Format: int32
             * @description width in cm
             *
             */
            width: number;
            /**
             * Format: int32
             * @description height in cm
             *
             */
            height: number;
            /** @description The license plate is a personal data item and must not be provided in an offer request.
             *     It must be patched into the offer after the customer accepted the offer for booking
             *      */
            licensePlate?: string | null;
        };
        TrainLink: {
            fromStation: components["schemas"]["StopPlaceRef"];
            toStation: components["schemas"]["StopPlaceRef"];
            train: string;
            /**
             * Format: date-time
             * @description date and time of the departure where the train link starts
             *
             */
            travelDate: string;
            serviceBrandCode: components["schemas"]["ServiceBrandCode"];
            /** @description Abbreviation of the service brand, e.g. 'IC', 'TGV'. See the OSDM code list. Needs to match the service brand code.
             *      */
            serviceBrandAbbreviation: string;
        };
        /** @description Validity depending on boarding / leaving of a train. The ticket is valid
         *     from departure until the destination station in the train if departure or destination is within the from - until range.
         *     The validation can reference the departure or the destination time to decide the validity (e.g. Eurail/Interrail passes
         *     currently use the departure for the validity on night trains).
         *      */
        TrainValidity: {
            /** Format: date-time */
            from: string;
            /** Format: date-time */
            until: string;
            carriers: components["schemas"]["CompanyRef"][];
            excludedServiceBrands?: components["schemas"]["ServiceBrandCode"][];
            includedServiceBrands?: components["schemas"]["ServiceBrandCode"][];
            scope: components["schemas"]["TrainValidityScope"];
        };
        /** @enum {string} */
        TrainValidityScope: "BOARDING" | "ARRIVAL";
        /** @description A leg which links other legs of a trip where a transfer between different places is required.
         *     Provided by OJP.
         *      */
        TransferLeg: {
            continuousMode?: components["schemas"]["ContinuousMode"];
            transferMode?: components["schemas"]["TransferMode"];
            start: components["schemas"]["PlaceRef"];
            end: components["schemas"]["PlaceRef"];
            /**
             * Format: date-time
             * @description Time at which window begins.
             *
             */
            timeWindowStart?: string | null;
            /**
             * Format: date-time
             * @description Time at which window ends.
             *
             */
            timeWindowEnd?: string | null;
            /**
             * Format: duration
             * @description Overall duration of this interchange.
             *
             * @example PT20M
             */
            duration?: string | null;
            situationFullRefs?: components["schemas"]["SituationFullRef"][];
            co2Emission?: components["schemas"]["Quantity"];
        };
        /** @description Modes dedicated to perform transfers. Provided by OJP.
         *      */
        TransferMode: string;
        Translation: {
            /** @description ISO-639-1 language code
             *      */
            language: string;
            text: string;
            shortText?: string | null;
        };
        /** @description Transportables which are handled similar to passengers like dogs, bicycles, car transport.
         *     These transportables might need a ticket or reservation.
         *      */
        Transportable: {
            type: components["schemas"]["TransportableType"];
            car?: components["schemas"]["Car"];
            motorCycle?: components["schemas"]["MotorCycle"];
            trailer?: components["schemas"]["Trailer"];
        };
        /** @description Subset of the values from
         *     the [Passenger Type Code List](https://osdm.io/spec/catalog-of-code-lists/#PassengerType)
         *     Listed values here are examples.
         *      */
        TransportableType: string;
        TravelAccountConsumption: {
            /** Format: date-time */
            consumedOn: string;
            bookingId: string;
            unit: components["schemas"]["AbstractTravelAccountUnit"];
            bookingSummary: string;
            tripSummary?: components["schemas"]["TripSummary"];
            /** Format: int32 */
            consumedAmount: number;
        };
        TravelAccountResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            travelAccount?: components["schemas"]["AbstractTravelAccount"];
        };
        /**
         * @default ALL
         * @enum {string}
         */
        TravelAccountResponseContent: "ALL" | "CONSUMPTIONS" | "NONE";
        /** @enum {string} */
        TravelAccountType: "LOYALTY_CARD" | "TRAVEL_PASS" | "MULTI_RIDE" | "REDUCTION_CARD";
        /** @description Traditional first and second class.
         *      */
        TravelClass: string;
        /** @description indication of the direction of travel standard direction is left
         *     to right with ascending coordinates in the layout values.
         *     Values from the [Travel Direction Code List](https://osdm.io/spec/catalog-of-code-lists/#TravelDirection)
         *     Listed values here are examples.
         *      */
        TravelDirectionType: string;
        TravelPassAccount: {
            objectType: "TravelPassAccount";
        } & (Omit<components["schemas"]["AbstractTravelAccount"], "objectType"> & {
            regionalConstraintSummary: string;
            regionalConstraint?: components["schemas"]["RegionalConstraint"];
            consumptions?: components["schemas"]["TravelAccountConsumption"][];
        });
        /** @description In distributor mode, travel validity data is needed to create barcode and control data (IRS 90918-4) even in case they have been checked during the on-line sale.
         *      */
        TravelValidity: {
            validTravelDates?: components["schemas"]["Calendar"];
            validityRange: components["schemas"]["ValidityRange"];
            /** @description time ranges excluded from the validity (e.g. off peak fulfillments)
             *      */
            excludedTimeRanges?: components["schemas"]["ExcludedTimeRange"][];
            /**
             * Format: int32
             * @description number of allowed travel days (e.g. 3 travel days within 2 weeks)
             *
             */
            numberOfTravelDays?: number | null;
            returnConstraint?: components["schemas"]["ReturnConstraint"];
            trainValidity?: components["schemas"]["TrainValidity"];
            validityType?: components["schemas"]["ValidityType"];
            tripAllocationConstraint?: components["schemas"]["TripAllocationConstraint"];
            tripInterruptionConstraint?: components["schemas"]["TripInterruptionConstraint"];
        };
        /** @description Range for the start of validity to be used in a patch for available fulfillments (e.g. a 1 hour ticket not
         *     available during  peak hours in the morning and afternoon).
         *      */
        TravelValidityRange: {
            /** Format: date */
            from: string;
            /** Format: date */
            until: string;
        };
        /** @description A complete trip from origin to destination. Provided by OJP.
         *      */
        Trip: {
            /** @description Id of this trip for referencing purposes. Unique within a trip list.
             *      */
            id: string;
            /** @description External reference of this trip for referencing purposes.
             *      */
            externalRef?: string | null;
            /** @description A human-readable description of the trip.
             *      */
            summary?: string | null;
            /**
             * Format: duration
             * @description Overall duration of the trip
             *
             * @example PT20M
             */
            duration: string;
            direction: components["schemas"]["TripDirectionType"];
            origin?: components["schemas"]["PlaceRef"];
            destination?: components["schemas"]["PlaceRef"];
            /**
             * Format: date-time
             * @description Departure time at origin.
             *
             */
            startTime: string;
            /**
             * Format: date-time
             * @description Arrival time at destination
             *
             */
            endTime: string;
            /**
             * Format: int32
             * @description Number of interchanges
             *
             */
            transfers: number;
            /**
             * Format: int32
             * @description Distance in meters over the the complete trip, i.e., including transfer legs.
             *
             */
            distance?: number | null;
            /** @description Legs ot the trip
             *      */
            legs: components["schemas"]["TripLeg"][];
            operatingDays?: components["schemas"]["OperatingDays"];
            /** @description Textual description of the operation days, e.g. 'Monday to Friday' or 'Not on holidays'.
             *      */
            operatingDaysDescription?: string | null;
            situationFullRefs?: components["schemas"]["SituationFullRef"][];
            tripStatus?: components["schemas"]["TripStatus"];
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        /** @description constraint on the use of a multiple trip ticket
         *      */
        TripAllocationConstraint: {
            allocationUnit: components["schemas"]["TripAllocationUnit"];
            /**
             * Format: int32
             * @description maximum number of allowed units to be allocated
             *
             */
            maxUnits?: number | null;
            /**
             * Format: duration
             * @description multiples of this duration can be allocated
             *
             * @example PT30M
             */
            durationUnit?: string | null;
            /** @description one of the listed processes is required for the allocation of a single trip
             *      */
            requiredProcesses: components["schemas"]["TripAllocationProcess"][];
        };
        /** @description Known Values:
         *     - NONE: Individual trips don't need to be allocated.
         *     - MANUAL: The passenger has to allocate a trip manually (This should not be used as it is by design non-interoperable).
         *     - ACTIVATION: Individual trips can be allocated by activation of the ticket.
         *     - FULFILLMENT: A new fulfillment needs to be created to allocate a trip.
         *      */
        TripAllocationProcess: string;
        /** @description Unit to allocate trips in a multi-trip fare. Trips can be allocated per day (e.g. Eurail) or per
         *     duration (e.g. multiples of a duration unit to cover the trip) or as single trips (e.g. carnet))
         *     Known Values:
         *     - NONE: Individual trips don't need to be allocated.
         *     - TRIP: allocation per individual trip.
         *     - DAY: The allocation is per travel day.
         *     - DURATION: the allocation is per duration.
         *      */
        TripAllocationUnit: string;
        /** @description Trip response structure. Provided by OJP.
         *      */
        TripCollectionResponse: {
            /** @deprecated */
            warning?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            id: string;
            trips?: components["schemas"]["Trip"][];
            tripSummaries?: components["schemas"]["TripSummary"][];
            /** @description
             *     Java Property Name: 'links'
             *      */
            _links?: components["schemas"]["Link"][];
        };
        /** @description The trip coverage defines which part of the trip is covered by the offer, offer part, booking or booking part, respectively.
         *
         *     If neither coveredLegIds nor coveredSections are defined, the complete trip is covered.
         *     coveredLegIds and coveredSections are mutually exclusive, i.e. only one of the structures can be present.
         *
         *     If either coveredLegIds or coveredSections is defined, the sectionIndex field must be filled to indicate which part of the trip is covered
         *     by the respective OfferPart or BookingPart
         *      */
        TripCoverage: {
            coveredTripId: string;
            /**
             * Format: int32
             * @description Describes which part of the trip (in order) is covered by the OfferPart/BookingPart which contains this TripCoverage structure.
             *
             *     This needs to be filled if either coveredLegIds or coveredSections is present.
             *
             */
            sectionIndex?: number | null;
            /** @description Indicate which legs are covered by the specific offer. Not used for fares.
             *      */
            coveredLegIds?: string[] | null;
            coveredSections?: components["schemas"]["Section"][];
        };
        /** @description Data to be included/excluded from search, f.e. modes, carriers. Provided by OJP.
         *      */
        TripDataFilter: {
            ptModeFilter?: components["schemas"]["ModeFilter"];
            carrierFilter?: components["schemas"]["CarrierFilter"];
            serviceBrandFilter?: components["schemas"]["ServiceBrandFilter"];
            vehicleFilter?: components["schemas"]["VehicleFilter"];
        };
        /**
         * @default OUT_BOUND
         * @enum {string}
         */
        TripDirectionType: "OUT_BOUND" | "IN_BOUND";
        /** @description rules on allowed trip interruptions. Interruptions due to a train change
         *     indicated by a trip search must not be included here.
         *      */
        TripInterruptionConstraint: {
            /**
             * Format: int32
             * @description maximum number of allowed interruptions
             *
             */
            maxInterruptions: number;
            /**
             * Format: duration
             * @description maximum duration of one interruption
             *
             * @example PT30M
             */
            maxDuration?: string | null;
            /**
             * Format: duration
             * @description maximum duration of all interruptions on the route
             *
             * @example PT30M
             */
            totalMaxDuration?: string | null;
            /** @description one of the listed processes is required for the interruption of the trip
             *      */
            requiredProcesses: components["schemas"]["TripInterruptionProcess"][];
        };
        /** @description Known Values:
         *     - NONE
         *     - MANUAL: passenger needs manual confirmation of train or station staff to interrupt the trip.
         *     - ACTIVATION: Passenger needs to deactivate the ticket during the interruption (via an app).
         *      */
        TripInterruptionProcess: string;
        /** @description A single stage of a trip that is made without change of MODE or service (ie:
         *     between each interchange). Provided by OJP.
         *      */
        TripLeg: {
            /** @description Id of this trip leg. Unique within trip result. A seqId is a leg id.
             *      */
            id: string;
            /** @description External reference of this tripLeg for referencing purposes.
             *      */
            externalRef?: string | null;
            timedLeg?: components["schemas"]["TimedLeg"];
            transferLeg?: components["schemas"]["TransferLeg"];
            continuousLeg?: components["schemas"]["ContinuousLeg"];
        };
        TripLegCoverage: {
            tripId: string;
            legId: string;
        };
        /** @description A minimal trip leg specification.
         *      */
        TripLegSpecification: {
            /** @description External reference of this trip leg. Unique within trip result.
             *      */
            externalRef?: string | null;
            timedLeg?: components["schemas"]["TimedLegSpecification"];
            transferLeg?: components["schemas"]["TransferLeg"];
        };
        /** @description Base mobility options to be applied for both public and individual transport.
         *     Provided by OJP.
         *      */
        TripMobilityFilter: {
            /**
             * @description The user wants to carry a bike on public transport.
             *
             * @default false
             */
            bikeTransport: boolean | null;
            /**
             * Format: int32
             * @description Deviation from average walk speed in percent. 100% percent is average speed.
             *
             * @default 100
             */
            walkSpeed: number;
            /**
             * Format: duration
             * @description Additional time added to all transfers (also to transfers between individual to
             *     public transport).
             *
             * @example 0S
             */
            additionalTransferTime?: string | null;
            /** Format: duration */
            minimalTransferTime?: string | null;
        };
        /** @description Options to control the search behavior and response contents.
         *     number of results > either number of results or number of results before and after are used.
         *     Provided by OJP.
         *      */
        TripParameters: {
            dataFilter?: components["schemas"]["TripDataFilter"];
            policyFilter?: components["schemas"]["BaseTripPolicyFilter"];
            mobilityFilter?: components["schemas"]["TripMobilityFilter"];
            /**
             * Format: int32
             * @default 5
             */
            numberOfResults: number;
            /**
             * Format: int32
             * @default 0
             */
            numberOfResultsBefore: number | null;
            /**
             * Format: int32
             * @default 5
             */
            numberOfResultsAfter: number;
            /** @default false */
            ignoreRealtimeData: boolean | null;
            /**
             * Format: int32
             * @description The maximum number of interchanges the user will accept per trip.
             *
             */
            transferLimit?: number | null;
            itModesToCover?: components["schemas"]["IndividualMode"];
        };
        TripResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            trip: components["schemas"]["Trip"];
        };
        /**
         * @default ALL
         * @enum {string}
         */
        TripResponseContent: "ALL" | "PLACES" | "NONE";
        /** @description Trip request structure. Provided by OJP.
         *      */
        TripSearchCriteria: {
            /** @description Needs to in local date time format.
             *      */
            departureTime?: string | null;
            /** @description Needs to in local date time format. If arrival time is provided the departure time must be omitted.
             *      */
            arrivalTime?: string | null;
            origin: components["schemas"]["PlaceRef"];
            destination: components["schemas"]["PlaceRef"];
            /** @description Ordered series of points where the journey must pass through. If more
             *     than one via point is given all of them must be obeyed - in the correct
             *     order. The server is allowed to replace a via stop by equivalent stops.
             *
             *     TripDataFilters given at a via apply to the section after that via. To apply a TripDataFilter for
             *     the first section (between the origin and the first via), use the TripDataFilter within the
             *     TripParameters structure.
             *      */
            vias?: components["schemas"]["TripVia"][];
            parameters?: components["schemas"]["TripParameters"];
            /** @description Influences whether referenced resources are returned in full or as references only. Proposed default ALL
             *      */
            embed?: components["schemas"]["TripsCollectionResponseContent"][];
            returnSearchParameters?: components["schemas"]["ReturnSearchParameters"];
            notVias?: components["schemas"]["NotVia"][];
        };
        /** @description Part of a trip.
         *      */
        TripSection: {
            tripId: string;
            coveredSection?: components["schemas"]["Section"];
        };
        /** @description A minimal trip specification from origin to destination.
         *      */
        TripSpecification: {
            /** @description External reference of this trip for referencing purposes. Unique within a trip specification.
             *      */
            externalRef?: string | null;
            legs: components["schemas"]["TripLegSpecification"][];
            /** @default false */
            isPartOfInternationalTrip: boolean | null;
            returnSearchParameters?: components["schemas"]["ReturnSearchParameters"];
        };
        TripStatus: {
            /**
             * @description Whether this trip is an additional one that has not been planned.
             *
             * @default false
             */
            unplanned: boolean | null;
            /**
             * @description Whether this trip is cancelled and will not be run.
             *
             * @default false
             */
            cancelled: boolean | null;
            /**
             * @description Whether this trip deviates from the planned service pattern.
             *
             * @default false
             */
            deviation: boolean | null;
            /**
             * @description Whether this trip is delayed.
             *
             * @default false
             */
            delayed: boolean | null;
            /**
             * @description Whether this trip cannot be used, due to operational delays and impossible transfers.
             *
             * @default false
             */
            infeasible: boolean | null;
        };
        /** @description Trip summary. Provided by OJP.
         *      */
        TripSummary: {
            /** @description Id of this trip for referencing purposes. Unique within trip response.
             *      */
            id: string;
            summary?: string | null;
            externalRef?: string | null;
            /**
             * Format: date-time
             * @description Departure time at origin.
             *
             */
            startTime?: string | null;
            /**
             * Format: date-time
             * @description Arrival time at destination.
             *
             */
            endTime?: string | null;
            /**
             * Format: duration
             * @description Overall duration of the trip.
             *
             */
            duration?: string | null;
            origin?: components["schemas"]["PlaceRef"];
            destination?: components["schemas"]["PlaceRef"];
            /** Format: int32 */
            transfers?: number | null;
            /** Format: int32 */
            distance?: number | null;
        };
        TripTravelAccountUnit: {
            objectType: "TripTravelAccountUnit";
        } & (Omit<components["schemas"]["AbstractTravelAccountUnit"], "objectType"> & Record<string, never>);
        /** @description Via restrictions for a trip. Provided by OJP.
         *     A TripDataFilter given applies to the section after this via.
         *      */
        TripVia: {
            viaPlace: components["schemas"]["PlaceRef"];
            /**
             * Format: duration
             * @description desired dwell time at the via place
             *
             * @example 30M
             */
            dwellTime?: string | null;
            dataFilter?: components["schemas"]["TripDataFilter"];
        };
        /**
         * @default ALL
         * @enum {string}
         */
        TripsCollectionResponseContent: "ALL" | "TRIPS" | "TRIPSUMMARIES" | "NONE";
        VAT: {
            countryCode: components["schemas"]["CountryCode"];
            /**
             * Format: int32
             * @description amount in cents
             *
             * @example 5
             */
            amount: number;
            /**
             * Format: int32
             * @description scale of the amount - the number of positions after the comma
             *
             * @default 2
             */
            scale: number;
            /** Format: float */
            percentage?: number | null;
            taxId?: string | null;
            scope?: components["schemas"]["VatScope"];
        };
        ValidityRange: {
            timeUnit: components["schemas"]["TimeUnit"];
            /** Format: int32 */
            value: number;
            /**
             * Format: int32
             * @description validity extended after midnight
             *
             */
            hoursAfterMidnight?: number | null;
        };
        /** @description Type of usage, either as single trip or multiple trips. Unrestricted fares might be combined into single trips if appropriate. Values from the [Travel Validity Type Code List](https://osdm.io/spec/catalog-of-code-lists/#TravelValidityType)
         *     Listed values here are examples.
         *      */
        ValidityType: string;
        /** @description scope where the VAT applies.
         *     Values from the [Tax Scope Code List](https://osdm.io/spec/catalog-of-code-lists/#TaxScope)
         *     Listed values here are examples.
         *      */
        VatScope: string;
        /** @description List of the coaches in a vehicle run ordered according to the physical
         *     ordering of the vehicle.
         *      */
        Vehicle: {
            coaches?: components["schemas"]["Coach"][];
            /** @description References to the reservations/fares for which all places in the vehicle can be selected.
             *     The reservation ids must be part of the list of reservation ids for which the consumer has
             *     requested the available places and the consumer must accept a list by setting
             *     singleSelectionMapsRequired to false
             *      */
            reservationRefs?: string[];
        };
        /** @description Filter for in/exclusion of vehicle based on vehicle number or line number.
         *      */
        VehicleFilter: {
            /**
             * @description Whether vehicle in list is to include or exclude from search.
             *
             * @default true
             */
            exclude: boolean;
            vehicleNumbers?: components["schemas"]["VehicleNumber"][];
            lineNumbers?: components["schemas"]["LineNumber"][];
        };
        /**
         * @description The vehicle number(s) of the vehicle that runs this timed leg. On some legs a vehicle can
         *     have multiple vehicle numbers, e.g. if it is split into two trains at a intermediate stop.
         *     E.g. the vehicle numbers of 'TGV 9218', 'TH 9340' or 'ICE 15'.
         *     For backwards compatibility with Hermes/Hosa the length of the string must be restricted
         *     to 5 characters. If's longer, it is not possible to use the H2O converter.
         *
         * @example 9218, 9340, 15
         */
        VehicleNumber: string | null;
        VoucherInformation: {
            issuer: components["schemas"]["CompanyRef"];
            /** @description voucher code provided by the issuer
             *      */
            code: string;
        };
        /** @description This element can be used to pass non-blocking information or events,
         *     such as a price difference with the initially offered price at booking time.
         *     It is inspired on the JSon problem structure.
         *      */
        Warning: {
            code: string;
            /**
             * Format: uri
             * @description An absolute URI that identifies the warning type. When dereferenced,
             *     it SHOULD provide human-readable documentation for the problem type
             *     (e.g., using HTML).
             *
             * @default about:blank
             * @example https://example.com/warns/price-updated
             */
            type: string;
            /**
             * @description A human readable explanation specific to this occurrence of the
             *     warning.
             *
             * @example The price of the given offer part has been updated during the booking operation
             */
            detail?: string | null;
            /**
             * Format: uri
             * @description An absolute URI that identifies the specific occurrence of the warning.
             *
             * @example offers/offer1234
             */
            instance?: string | null;
        };
        /** @description List of warnings.
         *      */
        WarningCollection: {
            warnings: components["schemas"]["Warning"][];
        };
        /** @description carrier - carrier responsible for the transport.
         *     entryStation - Station to enter the zone in case the product requires to enter the zone via a specific station
         *     (e.g. local zone ticket to start from the main rail station).
         *     terminalStation - Terminal station in case the product requires a destination within the zone (e.g. local ticket
         *     to go to the main rail station).
         *      */
        Zone: {
            /**
             * Format: byte
             * @description Id to support local traffic standards (e.g. VDV,...)
             *
             */
            binaryZoneId?: string | null;
            carrier: components["schemas"]["CompanyRef"];
            name?: string | null;
            entryStation?: components["schemas"]["StopPlace"];
            terminalStation?: components["schemas"]["StopPlace"];
            /** @description to be used in bar codes
             *      */
            zoneIds?: number[] | null;
            /** @description Nomenclature des units territoriales statistiques COMMISSION REGULATION (EU) No 31/2011
             *      */
            nutsCode?: string | null;
        };
        ZoneCollectionResponse: {
            /** @deprecated */
            warnings?: components["schemas"]["WarningCollection"];
            problems?: components["schemas"]["Problem"][];
            zones?: components["schemas"]["ZoneDefinition"][];
        };
        /** @description Definition of a zone used to define regional validity. The area of the zone can be defined via a
         *     geo-polygon, a complete list of all contained stations or area codes from the NUTS code list.
         *     The carrier is either the carrier or transport authority responsible for the definition.
         *      */
        ZoneDefinition: {
            id: string;
            name?: string | null;
            carrier: components["schemas"]["CompanyRef"];
            polygon?: components["schemas"]["Polygon"];
            nutsCodes?: string[] | null;
            places?: components["schemas"]["PlaceRef"][];
        };
    };
    responses: {
        /** @description See Other (303)
         *      */
        SeeOtherResponse: {
            headers: {
                /** @description Location (URN) of the response data
                 *      */
                Location?: string;
                /** @description Version tag
                 *      */
                ETag?: string;
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description Not Modified (304)
         *      */
        NotModifiedResponse: {
            headers: {
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description Bad Request (400)
         *      */
        BadRequestResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["Problem"];
            };
        };
        /** @description Cleanup successfully initiated
         *      */
        CleanupRequestAcceptedResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["WarningCollection"];
            };
        };
        /** @description Conflict (409)
         *      */
        ConflictResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["Problem"];
            };
        };
        /** @description default error response
         *      */
        DefaultErrorResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["Problem"];
            };
        };
        /** @description Forbidden (403)
         *      */
        ForbiddenResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["Problem"];
            };
        };
        /** @description Fulfillment successfully initiated, retrieve booking to retrieve the fulfillment documents
         *      */
        FulfillmentRequestAcceptedResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["WarningCollection"];
            };
        };
        /** @description Internal Server Error (500)
         *      */
        InternalServerErrorResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["Problem"];
            };
        };
        /** @description Not Acceptable (406)
         *      */
        NotAcceptableResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["Problem"];
            };
        };
        /** @description Not Found (404)
         *      */
        NotFoundResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["Problem"];
            };
        };
        /** @description Not Implemented (501)
         *      */
        NotImplementedResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["Problem"];
            };
        };
        /** @description Service Unavailable (503)
         *      */
        ServiceUnavailableResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["Problem"];
            };
        };
        /** @description Too Many Requests (429)
         *      */
        TooManyRequestsResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["Problem"];
            };
        };
        /** @description Unauthorized (401)
         *      */
        UnauthorizedResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["Problem"];
            };
        };
        /** @description Unsupported Media Type (415)
         *      */
        UnsupportedMediaTypeResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["Problem"];
            };
        };
    };
    parameters: {
        /** @description Describes the set of natural languages that are preferred for localized text in the response
         *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
         *      */
        acceptLanguage: string;
        /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
         *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
         *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
         *     globally unique.
         *      */
        idempotencyKey: string;
        /** @description The HTTP If-None-Match is used to check whether the providing system has a newer version of the requested data.
         *      */
        ifNoneMatch: string;
        /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
         *      */
        requestor: string;
        /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
         *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
         *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
         *      */
        traceParent: string;
        /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
         *     Storing information in tracestate is optional (see W3C Trace Context).
         *      */
        traceState: string;
        /**
         * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
         * @example x_swe, uic, iata
         */
        acceptNamespace: string;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getPlaces: {
        parameters: {
            query?: {
                /** @description can be used for pagination
                 *      */
                page?: string;
            };
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP If-None-Match is used to check whether the providing system has a newer version of the requested data.
                 *      */
                "If-None-Match"?: components["parameters"]["ifNoneMatch"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description places found
             *      */
            200: {
                headers: {
                    /** @description Resource is fairly persistent and has a medium time to live to allow short-term caching.
                     *      */
                    "Cache-Control"?: string;
                    /** @description version tag */
                    ETag?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PlaceResponse"];
                };
            };
            303: components["responses"]["SeeOtherResponse"];
            304: components["responses"]["NotModifiedResponse"];
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    postPlaces: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description request for place
         *      */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["PlaceRequest"];
            };
        };
        responses: {
            /** @description places found
             *      */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PlaceResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getPlacesId: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                /** @description id of the place to get.
                 *      */
                placeId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description place found
             *      */
            200: {
                headers: {
                    "Cache-Control"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PlaceResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    postTrips: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description request for trips
         *      */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["TripSearchCriteria"];
            };
        };
        responses: {
            /** @description trips found
             *      */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripCollectionResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getTripsCollectionId: {
        parameters: {
            query?: {
                page?: string;
                /** @description Influences whether referenced resources are returned in full or as references only.
                 *     Default value: ALL
                 *      */
                embed?: components["schemas"]["TripsCollectionResponseContent"][];
            };
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the trips
                 *      */
                tripsCollectionId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description trips found
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripCollectionResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getTripsId: {
        parameters: {
            query?: {
                /** @description Influences what stops are to be returned in response
                 *     (ORIGIN_DESTINATION_ONLY returns no intermediate stops;
                 *     REAL_BOARDING_ALIGHTING returns all stops except virtual stops).
                 *     Default value: ORIGIN_DESTINATION_ONLY
                 *      */
                stopBehavior?: components["schemas"]["StopBehavior"];
                /** @description Influences whether referenced resources are returned in full or as references only.
                 *     Default value: ALL
                 *      */
                embed?: components["schemas"]["TripResponseContent"][];
            };
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the trip to get.
                 *      */
                tripId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description trip found
             *      */
            200: {
                headers: {
                    "Cache-Control"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    createOffers: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["OfferCollectionRequest"];
            };
        };
        responses: {
            /** @description collection of offers found
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OfferCollectionResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getBookingBookedOffersAdditionalOffers: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                bookingId: string;
                bookedOfferId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description additional offers found for booked offer
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AdditionalOfferCollectionResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    createOnHoldOffer: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
            };
            path: {
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OnHoldOfferRequest"];
            };
        };
        responses: {
            /** @description on-hold offer created
             *      */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OnHoldOfferResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    deleteOnHoldOffer: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                bookingId: string;
                onHoldOfferId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description In case that a request was successful only status code 204 will be returned but no response content will be provided (aka as return type 'void' in many programming languages).
             *      */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    confirmOnHoldOffer: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
            };
            path: {
                bookingId: string;
                onHoldOfferId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OnHoldOfferPatchRequest"];
            };
        };
        responses: {
            /** @description on-hold offer confirmed
             *      */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OnHoldOfferResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getBookingPassengersId: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                /** @description id of the booking
                 *      */
                bookingId: string;
                /** @description id of the passenger
                 *      */
                passengerId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description passenger found
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PassengerResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    patchBookingPassenger: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                /** @description id of the booking the passenger is in.
                 *      */
                bookingId: string;
                /** @description id of the passenger
                 *      */
                passengerId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["Passenger"];
            };
        };
        responses: {
            /** @description passenger successfully patched
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PassengerResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getBookingPurchaser: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                /** @description id of the booking the purchaser is in.
                 *      */
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description purchaser found
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PurchaserResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    patchBookingPurchaser: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                /** @description id of the booking the purchaser is in.
                 *      */
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["Purchaser"];
            };
        };
        responses: {
            /** @description purchaser patched
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PurchaserResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    postBookingBookedOffers: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BookedOfferRequest"];
            };
        };
        responses: {
            /** @description booking pre-booked
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookedOfferResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getBookingBookedOffersId: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                bookingId: string;
                bookedOfferId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description bookedOffer found
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookedOfferResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    deleteBookingBookedOffersId: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                bookingId: string;
                bookedOfferId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description In case that a request was successful only status code 204 will be returned but no response content will be provided (aka as return type 'void' in many programming languages).
             *      */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    deleteBookingBookedOffersIdPassengerId: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                bookingId: string;
                offerId: string;
                passengerId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description In case that a request was successful only status code 204 will be returned but no response content will be provided (aka as return type 'void' in many programming languages).
             *      */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    createBookingBookedOffersReservations: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
            };
            path: {
                bookingId: string;
                bookedOfferId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BookedOfferReservationRequest"];
            };
        };
        responses: {
            /** @description reservation added to booked offer
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookedOfferReservationResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    deleteBookingBookedOffersReservations: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                bookingId: string;
                bookedOfferId: string;
                reservationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description In case that a request was successful only status code 204 will be returned but no response content will be provided (aka as return type 'void' in many programming languages).
             *      */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    createBookingBookedOffersAncillaries: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
            };
            path: {
                bookingId: string;
                bookedOfferId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BookedOfferAncillaryRequest"];
            };
        };
        responses: {
            /** @description ancillary added to booked offer
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookedOfferAncillaryResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    deleteBookingBookedOffersAncillary: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                bookingId: string;
                bookedOfferId: string;
                ancillaryId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description In case that a request was successful only status code 204 will be returned but no response content will be provided (aka as return type 'void' in many programming languages).
             *      */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    deleteBookingBookedOffersAdmission: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                bookingId: string;
                bookedOfferId: string;
                admissionId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description In case that a request was successful only status code 204 will be returned but no response content will be provided (aka as return type 'void' in many programming languages).
             *      */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    postBookings: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BookingRequest"];
            };
        };
        responses: {
            /** @description booking pre-booked
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookingResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getBookingsId: {
        parameters: {
            query?: {
                /** @description Influences whether referenced resources are returned in full or as references only.
                 *     Default value: ALL
                 *      */
                embed?: components["schemas"]["BookingResponseContent"][];
            };
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the booking to get.
                 *      */
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description booking found
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookingResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    deleteBookingsId: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                /** @description id of the booking to delete.
                 *      */
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description In case that a request was successful only status code 204 will be returned but no response content will be provided (aka as return type 'void' in many programming languages).
             *      */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    updateBooking: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the booking to be patched
                 *      */
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BookingPatchRequest"];
            };
        };
        responses: {
            /** @description booking fulfillment type updated
             *      */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookingResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    postBookingCleanup: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
            };
            path: {
                /** @description id of the booking.
                 *      */
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BookingCleanupRequest"];
            };
        };
        responses: {
            202: components["responses"]["CleanupRequestAcceptedResponse"];
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getBookingsIdHistory: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                /** @description id of the booking to get.
                 *      */
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description booking history found
             *      */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookingHistoryResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    searchBookings: {
        parameters: {
            query?: {
                page?: string;
            };
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BookingSearchRequest"];
            };
        };
        responses: {
            /** @description booking search results found
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookingSearchResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    splitBookings: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
            };
            path: {
                /** @description id of the booking to be split
                 *      */
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BookingSplitRequest"];
            };
        };
        responses: {
            /** @description booking split
             *      */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookingSplitResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    postFulfillments: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the booking to be patched
                 *      */
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["FulfillmentPostRequest"];
            };
        };
        responses: {
            /** @description Fulfillment successfully completed
             *      */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FulfillmentCollectionResponse"];
                };
            };
            202: components["responses"]["FulfillmentRequestAcceptedResponse"];
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    finalizeFulfillments: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the booking to be patched
                 *      */
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FulfillmentPatchRequest"];
            };
        };
        responses: {
            /** @description Fulfillment successfully completed
             *      */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FulfillmentCollectionResponse"];
                };
            };
            202: components["responses"]["FulfillmentRequestAcceptedResponse"];
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getFulfillmentId: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the fulfillment to get.
                 *      */
                fulfillmentId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description fulfillment found
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FulfillmentResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    patchFulfillmentId: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                fulfillmentId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FulfillmentActivationPatchRequest"];
            };
        };
        responses: {
            /** @description fulfillment patched
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FulfillmentResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    postRefundOffers: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the booking.
                 *      */
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RefundOfferRequest"];
            };
        };
        responses: {
            /** @description refund offer created
             *      */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RefundOfferCollectionResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getRefundOffers: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the booking
                 *      */
                bookingId: string;
                /** @description id of the refund offer to get.
                 *      */
                refundOfferId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description refund offer found
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RefundOfferResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    deleteRefundOffers: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                /** @description id of the booking
                 *      */
                bookingId: string;
                /** @description id of the refund offer
                 *      */
                refundOfferId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description refund offer deleted
             *      */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    patchRefundOffers: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the booking
                 *      */
                bookingId: string;
                /** @description id of the refund offer
                 *      */
                refundOfferId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RefundOfferPatchRequest"];
            };
        };
        responses: {
            /** @description refund offer confirmed
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RefundOfferResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    postReleaseOffers: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the booking.
                 *      */
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ReleaseOfferRequest"];
            };
        };
        responses: {
            /** @description release offer created
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReleaseOfferCollectionResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getReleaseOffer: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the booking
                 *      */
                bookingId: string;
                /** @description id of the release offer to get.
                 *      */
                releaseOfferId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description release offer found
             *      */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReleaseOfferResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    deleteReleaseOffers: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                /** @description id of the booking
                 *      */
                bookingId: string;
                /** @description id of the release offer
                 *      */
                releaseOfferId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description release offer deleted
             *      */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    patchReleaseOffers: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the booking
                 *      */
                bookingId: string;
                /** @description id of the release offer
                 *      */
                releaseOfferId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ReleaseOfferPatchRequest"];
            };
        };
        responses: {
            /** @description release offer confirmed
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReleaseOfferResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    postCancelFulfillmentsOffers: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the booking.
                 *      */
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CancelFulfillmentsOfferRequest"];
            };
        };
        responses: {
            /** @description Refund offer created
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CancelFulfillmentsOfferCollectionResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getCancelFulfillmentOffers: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the booking
                 *      */
                bookingId: string;
                cancelFulfillmentsOfferId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description RefundOffer found
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CancelFulfillmentsOfferResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    deleteCancelFulfillmentOffers: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                /** @description id of the booking
                 *      */
                bookingId: string;
                cancelFulfillmentsOfferId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description In case that a request was successful only status code 204 will be returned but no response content will be provided (aka as return type 'void' in many programming languages).
             *      */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    patchCancelFulfillmentsOffers: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the booking
                 *      */
                bookingId: string;
                /** @description id of the cancel fulfillment offer
                 *      */
                cancelFulfillmentsOfferId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CancelFulfillmentsOfferPatchRequest"];
            };
        };
        responses: {
            /** @description RefundOffer confirmed
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CancelFulfillmentsOfferResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    createExchangeOffersCollection: {
        parameters: {
            query: {
                embed: components["schemas"]["ExchangeOfferCollectionResponseContent"];
            };
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
            };
            path: {
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ExchangeOfferCollectionRequest"];
            };
        };
        responses: {
            /** @description Collection of exchange offers found
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExchangeOfferCollectionResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    createBookingsExchangeOperations: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ExchangeOperationRequest"];
            };
        };
        responses: {
            /** @description exchange offer pre-booked
             *      */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExchangeOperationResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getBookingsExchangeOperations: {
        parameters: {
            query?: {
                /** @description Influences whether referenced resources are returned in full or as references only.
                 *     Default value: ALL
                 *      */
                embed?: components["schemas"]["ExchangeOperationResponseContent"][];
            };
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the booking
                 *      */
                bookingId: string;
                /** @description id of the exchange operation
                 *      */
                exchangeOperationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description ExchangeOperation found
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExchangeOperationResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    deleteBookingsExchangeOperation: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                /** @description id of the booking containing the exchange operation
                 *      */
                bookingId: string;
                /** @description id of the exchangeOperation to delete.
                 *      */
                exchangeOperationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description In case that a request was successful only status code 204 will be returned but no response content will be provided (aka as return type 'void' in many programming languages).
             *      */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    updateBookingsExchangeOperations: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the booking to be exchanged.
                 *      */
                bookingId: string;
                /** @description id of the exchange operation.
                 *      */
                exchangeOperationId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ExchangeOperationPatchRequest"];
            };
        };
        responses: {
            /** @description Exchange successfully completed
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExchangeOperationResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    createComplaint: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["Complaint"];
            };
        };
        responses: {
            /** @description complaint
             *      */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ComplaintResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getComplaint: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                /** @description id of the complaint
                 *      */
                complaintId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description the requested complaint
             *      */
            200: {
                headers: {
                    "Cache-Control"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ComplaintResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    patchComplaint: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /** @description The HTTP Idempotency request header field can be used to carry idempotency key in order to make
                 *     non-idempotent HTTP methods such as POST or PATCH fault-tolerant. Servers should keep the idempotency
                 *     key for as long as the result of the underlying operation is valid. Idempotency keys should be
                 *     globally unique.
                 *      */
                "Idempotency-Key"?: components["parameters"]["idempotencyKey"];
            };
            path: {
                /** @description id of the complaint to be patched
                 *      */
                complaintId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ComplaintPatchRequest"];
            };
        };
        responses: {
            /** @description complaint updated
             *      */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ComplaintResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getCoachLayouts: {
        parameters: {
            query?: {
                page?: string;
            };
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description coach layouts
             *      */
            200: {
                headers: {
                    "Cache-Control"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CoachLayoutCollectionResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getCoachLayoutsLayoutId: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                /** @description id of the layout
                 *      */
                layoutId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description coach layouts
             *      */
            200: {
                headers: {
                    "Cache-Control"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CoachLayoutResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getReductionCards: {
        parameters: {
            query?: {
                page?: string;
            };
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Reduction cards provided
             *      */
            200: {
                headers: {
                    "Cache-Control"?: string;
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReductionCardCollectionResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getZones: {
        parameters: {
            query?: {
                page?: string;
            };
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description zones provided
             *      */
            200: {
                headers: {
                    "Cache-Control"?: string;
                    "Content-Language"?: string;
                    Expires?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneCollectionResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    createDocuments: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DocumentRequest"];
            };
        };
        responses: {
            /** @description booking documents created
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DocumentCollectionResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getDocument: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                bookingId: string;
                documentId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description booking document found
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DocumentResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    deleteBookingsDocumentsId: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                bookingId: string;
                documentId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description In case that a request was successful only status code 204 will be returned but no response content will be provided (aka as return type 'void' in many programming languages).
             *      */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    createReimbursement: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                bookingId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ReimbursementRequest"];
            };
        };
        responses: {
            /** @description Reimbursement created
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReimbursementResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getReimbursement: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                bookingId: string;
                reimbursementId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description reimbursement found
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReimbursementResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    updateReimbursement: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path: {
                bookingId: string;
                reimbursementId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ReimbursementPatchRequest"];
            };
        };
        responses: {
            /** @description reimbursement updated
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReimbursementResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            409: components["responses"]["ConflictResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getTravelAccounts: {
        parameters: {
            query: {
                issuer: string;
                travelAccount: string;
                /** @description Default value: ALL
                 *      */
                embed?: components["schemas"]["TravelAccountResponseContent"][];
            };
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description travel account found
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TravelAccountResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getAvailabilitiesPlaceMap: {
        parameters: {
            query: {
                contextId: string;
                contextType: components["schemas"]["ContextType"];
                resourceId: string;
                resourceType: components["schemas"]["ResourceType"];
            };
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PlaceAvailabilityResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getAvailabilitiesPlaceMaps: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AvailabilityScope"];
            };
        };
        responses: {
            /** @description place availabilities for the requested fares and offer parts
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PlaceAvailability"][];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getAvailabilitiesNearby: {
        parameters: {
            query: {
                /** @description denotes the offerId when contextType is OFFER, bookingId when contextType is BOOKING
                 *      */
                contextId: string;
                contextType: components["schemas"]["ContextType"];
                /** @description denotes the reservationId wen resourceType is RESERVATION, fareId when resourceType is FARE
                 *      */
                resourceId: string;
                resourceType: components["schemas"]["ResourceType"];
                /** @description coach number of the referenced place
                 *      */
                coachNumber: string;
                /** @description place number of the referenced place
                 *      */
                placeNumber: string;
            };
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description place availabilities found
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PlaceAvailabilityCollectionResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getAvailabilitiesPreferences: {
        parameters: {
            query: {
                contextId: string;
                contextType: components["schemas"]["ContextType"];
                resourceId: string;
                resourceType: components["schemas"]["ResourceType"];
            };
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description place availabilities found
             *      */
            200: {
                headers: {
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PlaceAvailabilityCollectionResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getProducts: {
        parameters: {
            query?: {
                page?: string;
            };
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Product found
             *      */
            200: {
                headers: {
                    "Cache-Control"?: string;
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProductCollectionResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
    getProductsId: {
        parameters: {
            query?: never;
            header: {
                /** @description The requestor header contains detailed information about who is calling the API. It can include information such as channel, organization, sales unit or workstation id and be used to configure e.g. the fare range provided to the caller. The content of the string is part of a bilateral contract by the two parties and not standardized by OSDM. It is recommend to encrypt the information transferred.
                 *      */
                Requestor: components["parameters"]["requestor"];
                /** @description Describes the set of natural languages that are preferred for localized text in the response
                 *     to the request (see RFC2616-sec14.4). Supporting English (en) is a must.
                 *      */
                "Accept-Language"?: components["parameters"]["acceptLanguage"];
                /** @description The traceparent header describes the position of the incoming request in its trace graph in a portable,
                 *     fixed-length format. Its design focuses on fast parsing. Every tracing tool MUST properly set
                 *     traceparent even when it only relies on vendor-specific information in tracestate (see W3C Trace Context).
                 *      */
                traceparent?: components["parameters"]["traceParent"];
                /** @description The tracestate extends traceparent with vendor-specific data represented by a set of name/value pairs.
                 *     Storing information in tracestate is optional (see W3C Trace Context).
                 *      */
                tracestate?: components["parameters"]["traceState"];
                /**
                 * @description The x-accept-namespace HTTP header indicates the URN namespace that the client prefers. The provider uses content-negotiation to apply the corresponding namespace(s) where applicable.
                 * @example x_swe, uic, iata
                 */
                "x-accept-namespace"?: components["parameters"]["acceptNamespace"];
            };
            path: {
                /** @description id of the product to get
                 *      */
                productId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Product found
             *      */
            200: {
                headers: {
                    "Cache-Control"?: string;
                    "Content-Language"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProductResponse"];
                };
            };
            400: components["responses"]["BadRequestResponse"];
            401: components["responses"]["UnauthorizedResponse"];
            403: components["responses"]["ForbiddenResponse"];
            404: components["responses"]["NotFoundResponse"];
            406: components["responses"]["NotAcceptableResponse"];
            415: components["responses"]["UnsupportedMediaTypeResponse"];
            429: components["responses"]["TooManyRequestsResponse"];
            500: components["responses"]["InternalServerErrorResponse"];
            501: components["responses"]["NotImplementedResponse"];
            503: components["responses"]["ServiceUnavailableResponse"];
            default: components["responses"]["DefaultErrorResponse"];
        };
    };
}
